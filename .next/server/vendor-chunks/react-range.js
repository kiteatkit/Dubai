"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-range";
exports.ids = ["vendor-chunks/react-range"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-range/lib/Range.js":
/*!***********************************************!*\
  !*** ./node_modules/react-range/lib/Range.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar React = __importStar(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"));\nvar utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-range/lib/utils.js\");\nvar types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/react-range/lib/types.js\");\nvar INCREASE_KEYS = [\"ArrowRight\", \"ArrowUp\", \"k\", \"PageUp\"];\nvar DECREASE_KEYS = [\"ArrowLeft\", \"ArrowDown\", \"j\", \"PageDown\"];\nvar Range = /** @class */ (function (_super) {\n    __extends(Range, _super);\n    function Range(props) {\n        var _this = _super.call(this, props) || this;\n        _this.trackRef = React.createRef();\n        _this.thumbRefs = [];\n        _this.state = {\n            draggedTrackPos: [-1, -1],\n            draggedThumbIndex: -1,\n            thumbZIndexes: new Array(_this.props.values.length).fill(0).map(function (t, i) { return i; }),\n            isChanged: false,\n            markOffsets: [],\n        };\n        _this.getOffsets = function () {\n            var _a = _this.props, direction = _a.direction, values = _a.values, min = _a.min, max = _a.max;\n            var trackElement = _this.trackRef.current;\n            if (!trackElement) {\n                console.warn(\"No track element found.\");\n                return [];\n            }\n            var trackRect = trackElement.getBoundingClientRect();\n            var trackPadding = (0, utils_1.getPaddingAndBorder)(trackElement);\n            return _this.getThumbs().map(function (thumb, index) {\n                var thumbOffsets = { x: 0, y: 0 };\n                var thumbRect = thumb.getBoundingClientRect();\n                var thumbMargins = (0, utils_1.getMargin)(thumb);\n                switch (direction) {\n                    case types_1.Direction.Right:\n                        thumbOffsets.x = (thumbMargins.left + trackPadding.left) * -1;\n                        thumbOffsets.y =\n                            ((thumbRect.height - trackRect.height) / 2 + trackPadding.top) * -1;\n                        thumbOffsets.x +=\n                            trackRect.width * (0, utils_1.relativeValue)(values[index], min, max) -\n                                thumbRect.width / 2;\n                        return thumbOffsets;\n                    case types_1.Direction.Left:\n                        thumbOffsets.x = (thumbMargins.right + trackPadding.right) * -1;\n                        thumbOffsets.y =\n                            ((thumbRect.height - trackRect.height) / 2 + trackPadding.top) * -1;\n                        thumbOffsets.x +=\n                            trackRect.width -\n                                trackRect.width * (0, utils_1.relativeValue)(values[index], min, max) -\n                                thumbRect.width / 2;\n                        return thumbOffsets;\n                    case types_1.Direction.Up:\n                        thumbOffsets.x =\n                            ((thumbRect.width - trackRect.width) / 2 +\n                                thumbMargins.left +\n                                trackPadding.left) *\n                                -1;\n                        thumbOffsets.y = -trackPadding.left;\n                        thumbOffsets.y +=\n                            trackRect.height -\n                                trackRect.height * (0, utils_1.relativeValue)(values[index], min, max) -\n                                thumbRect.height / 2;\n                        return thumbOffsets;\n                    case types_1.Direction.Down:\n                        thumbOffsets.x =\n                            ((thumbRect.width - trackRect.width) / 2 +\n                                thumbMargins.left +\n                                trackPadding.left) *\n                                -1;\n                        thumbOffsets.y = -trackPadding.left;\n                        thumbOffsets.y +=\n                            trackRect.height * (0, utils_1.relativeValue)(values[index], min, max) -\n                                thumbRect.height / 2;\n                        return thumbOffsets;\n                    default:\n                        return (0, utils_1.assertUnreachable)(direction);\n                }\n            });\n        };\n        _this.getThumbs = function () {\n            if (_this.trackRef && _this.trackRef.current) {\n                return Array.from(_this.trackRef.current.children).filter(function (el) {\n                    return el.hasAttribute(\"aria-valuenow\");\n                });\n            }\n            console.warn(\"No thumbs found in the track container. Did you forget to pass & spread the `props` param in renderTrack?\");\n            return [];\n        };\n        _this.getTargetIndex = function (e) {\n            return _this.getThumbs().findIndex(function (child) { return child === e.target || child.contains(e.target); });\n        };\n        _this.addTouchEvents = function (e) {\n            document.addEventListener(\"touchmove\", _this.schdOnTouchMove, {\n                passive: false,\n            });\n            document.addEventListener(\"touchend\", _this.schdOnEnd, {\n                passive: false,\n            });\n            document.addEventListener(\"touchcancel\", _this.schdOnEnd, {\n                passive: false,\n            });\n        };\n        _this.addMouseEvents = function (e) {\n            document.addEventListener(\"mousemove\", _this.schdOnMouseMove);\n            document.addEventListener(\"mouseup\", _this.schdOnEnd);\n        };\n        _this.onMouseDownTrack = function (e) {\n            var _a;\n            if (e.button !== 0 || (0, utils_1.isIOS)())\n                return;\n            e.persist();\n            e.preventDefault();\n            _this.addMouseEvents(e.nativeEvent);\n            if (_this.props.values.length > 1 && _this.props.draggableTrack) {\n                if (_this.thumbRefs.some(function (thumbRef) { var _a; return (_a = thumbRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target); }))\n                    return;\n                // handle dragging the whole track\n                _this.setState({\n                    draggedTrackPos: [e.clientX, e.clientY],\n                }, function () { return _this.onMove(e.clientX, e.clientY); });\n            }\n            else {\n                // get the index of the thumb that is closest to the place where the track is clicked\n                var draggedThumbIndex = (0, utils_1.getClosestThumbIndex)(_this.thumbRefs.map(function (t) { return t.current; }), e.clientX, e.clientY, _this.props.direction);\n                // move the thumb which is closest to the place where the track is clicked\n                (_a = _this.thumbRefs[draggedThumbIndex].current) === null || _a === void 0 ? void 0 : _a.focus();\n                _this.setState({\n                    draggedThumbIndex: draggedThumbIndex,\n                }, function () { return _this.onMove(e.clientX, e.clientY); });\n            }\n        };\n        _this.onResize = function () {\n            (0, utils_1.translateThumbs)(_this.getThumbs(), _this.getOffsets(), _this.props.rtl);\n            _this.calculateMarkOffsets();\n        };\n        _this.onTouchStartTrack = function (e) {\n            var _a;\n            e.persist();\n            _this.addTouchEvents(e.nativeEvent);\n            if (_this.props.values.length > 1 && _this.props.draggableTrack) {\n                if (_this.thumbRefs.some(function (thumbRef) { var _a; return (_a = thumbRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target); }))\n                    return;\n                // handle dragging the whole track\n                _this.setState({\n                    draggedTrackPos: [e.touches[0].clientX, e.touches[0].clientY],\n                }, function () { return _this.onMove(e.touches[0].clientX, e.touches[0].clientY); });\n            }\n            else {\n                // get the index of the thumb that is closest to the place where the track is clicked\n                var draggedThumbIndex = (0, utils_1.getClosestThumbIndex)(_this.thumbRefs.map(function (t) { return t.current; }), e.touches[0].clientX, e.touches[0].clientY, _this.props.direction);\n                // move the thumb which is closest to the place where the track is clicked\n                (_a = _this.thumbRefs[draggedThumbIndex].current) === null || _a === void 0 ? void 0 : _a.focus();\n                _this.setState({\n                    draggedThumbIndex: draggedThumbIndex,\n                }, function () { return _this.onMove(e.touches[0].clientX, e.touches[0].clientY); });\n            }\n        };\n        _this.onMouseOrTouchStart = function (e) {\n            if (_this.props.disabled)\n                return;\n            var isTouch = (0, utils_1.isTouchEvent)(e);\n            if (!isTouch && e.button !== 0)\n                return;\n            var index = _this.getTargetIndex(e);\n            if (index === -1)\n                return;\n            if (isTouch) {\n                _this.addTouchEvents(e);\n            }\n            else {\n                _this.addMouseEvents(e);\n            }\n            _this.setState({\n                draggedThumbIndex: index,\n                thumbZIndexes: _this.state.thumbZIndexes.map(function (t, i) {\n                    if (i === index) {\n                        return Math.max.apply(Math, _this.state.thumbZIndexes);\n                    }\n                    return t <= _this.state.thumbZIndexes[index] ? t : t - 1;\n                }),\n            });\n        };\n        _this.onMouseMove = function (e) {\n            e.preventDefault();\n            _this.onMove(e.clientX, e.clientY);\n        };\n        _this.onTouchMove = function (e) {\n            e.preventDefault();\n            _this.onMove(e.touches[0].clientX, e.touches[0].clientY);\n        };\n        _this.onKeyDown = function (e) {\n            var _a = _this.props, values = _a.values, onChange = _a.onChange, step = _a.step, rtl = _a.rtl, direction = _a.direction;\n            var isChanged = _this.state.isChanged;\n            var index = _this.getTargetIndex(e.nativeEvent);\n            var inverter = rtl || direction === types_1.Direction.Left || direction === types_1.Direction.Down\n                ? -1\n                : 1;\n            if (index === -1)\n                return;\n            if (INCREASE_KEYS.includes(e.key)) {\n                e.preventDefault();\n                _this.setState({\n                    draggedThumbIndex: index,\n                    isChanged: true,\n                });\n                onChange((0, utils_1.replaceAt)(values, index, _this.normalizeValue(values[index] + inverter * (e.key === \"PageUp\" ? step * 10 : step), index)));\n            }\n            else if (DECREASE_KEYS.includes(e.key)) {\n                e.preventDefault();\n                _this.setState({\n                    draggedThumbIndex: index,\n                    isChanged: true,\n                });\n                onChange((0, utils_1.replaceAt)(values, index, _this.normalizeValue(values[index] -\n                    inverter * (e.key === \"PageDown\" ? step * 10 : step), index)));\n            }\n            else if (e.key === \"Tab\") {\n                _this.setState({ draggedThumbIndex: -1 }, function () {\n                    // If key pressed when thumb was moving, fire onFinalChange\n                    if (isChanged) {\n                        _this.fireOnFinalChange();\n                    }\n                });\n            }\n            else {\n                if (isChanged) {\n                    _this.fireOnFinalChange();\n                }\n            }\n        };\n        _this.onKeyUp = function (e) {\n            var isChanged = _this.state.isChanged;\n            _this.setState({\n                draggedThumbIndex: -1,\n            }, function () {\n                if (isChanged) {\n                    _this.fireOnFinalChange();\n                }\n            });\n        };\n        _this.onMove = function (clientX, clientY) {\n            var _a = _this.state, draggedThumbIndex = _a.draggedThumbIndex, draggedTrackPos = _a.draggedTrackPos;\n            var _b = _this.props, direction = _b.direction, min = _b.min, max = _b.max, onChange = _b.onChange, values = _b.values, step = _b.step, rtl = _b.rtl;\n            if (draggedThumbIndex === -1 &&\n                draggedTrackPos[0] === -1 &&\n                draggedTrackPos[1] === -1)\n                return null;\n            var trackElement = _this.trackRef.current;\n            // If component was closed down prematurely, A last onMove could be triggered based on requestAnimationFrame()\n            if (!trackElement)\n                return null;\n            var trackRect = trackElement.getBoundingClientRect();\n            var trackLength = (0, utils_1.isVertical)(direction)\n                ? trackRect.height\n                : trackRect.width;\n            if (draggedTrackPos[0] !== -1 && draggedTrackPos[1] !== -1) {\n                // calculate how much it moved since the last update\n                var dX = clientX - draggedTrackPos[0];\n                var dY = clientY - draggedTrackPos[1];\n                // calculate the delta of the value\n                var deltaValue = 0;\n                switch (direction) {\n                    case types_1.Direction.Right:\n                    case types_1.Direction.Left:\n                        deltaValue = (dX / trackLength) * (max - min);\n                        break;\n                    case types_1.Direction.Down:\n                    case types_1.Direction.Up:\n                        deltaValue = (dY / trackLength) * (max - min);\n                        break;\n                    default:\n                        (0, utils_1.assertUnreachable)(direction);\n                }\n                // invert for RTL\n                if (rtl) {\n                    deltaValue *= -1;\n                }\n                if (Math.abs(deltaValue) >= step / 2) {\n                    // adjust delta so it fits into the range\n                    for (var i = 0; i < _this.thumbRefs.length; i++) {\n                        if ((values[i] === max && Math.sign(deltaValue) === 1) ||\n                            (values[i] === min && Math.sign(deltaValue) === -1))\n                            return;\n                        var thumbValue = values[i] + deltaValue;\n                        if (thumbValue > max)\n                            deltaValue = max - values[i];\n                        else if (thumbValue < min)\n                            deltaValue = min - values[i];\n                    }\n                    // add the delta to each thumb\n                    var newValues = values.slice(0);\n                    for (var i = 0; i < _this.thumbRefs.length; i++) {\n                        newValues = (0, utils_1.replaceAt)(newValues, i, _this.normalizeValue(values[i] + deltaValue, i));\n                    }\n                    _this.setState({\n                        draggedTrackPos: [clientX, clientY],\n                    });\n                    onChange(newValues);\n                }\n            }\n            else {\n                var newValue = 0;\n                switch (direction) {\n                    case types_1.Direction.Right:\n                        newValue =\n                            ((clientX - trackRect.left) / trackLength) * (max - min) + min;\n                        break;\n                    case types_1.Direction.Left:\n                        newValue =\n                            ((trackLength - (clientX - trackRect.left)) / trackLength) *\n                                (max - min) +\n                                min;\n                        break;\n                    case types_1.Direction.Down:\n                        newValue =\n                            ((clientY - trackRect.top) / trackLength) * (max - min) + min;\n                        break;\n                    case types_1.Direction.Up:\n                        newValue =\n                            ((trackLength - (clientY - trackRect.top)) / trackLength) *\n                                (max - min) +\n                                min;\n                        break;\n                    default:\n                        (0, utils_1.assertUnreachable)(direction);\n                }\n                // invert for RTL\n                if (rtl) {\n                    newValue = max + min - newValue;\n                }\n                if (Math.abs(values[draggedThumbIndex] - newValue) >= step / 2) {\n                    onChange((0, utils_1.replaceAt)(values, draggedThumbIndex, _this.normalizeValue(newValue, draggedThumbIndex)));\n                }\n            }\n        };\n        _this.normalizeValue = function (value, index) {\n            var _a = _this.props, min = _a.min, max = _a.max, step = _a.step, allowOverlap = _a.allowOverlap, values = _a.values;\n            return (0, utils_1.normalizeValue)(value, index, min, max, step, allowOverlap, values);\n        };\n        _this.onEnd = function (e) {\n            e.preventDefault();\n            document.removeEventListener(\"mousemove\", _this.schdOnMouseMove);\n            document.removeEventListener(\"touchmove\", _this.schdOnTouchMove);\n            document.removeEventListener(\"mouseup\", _this.schdOnEnd);\n            document.removeEventListener(\"touchend\", _this.schdOnEnd);\n            document.removeEventListener(\"touchcancel\", _this.schdOnEnd);\n            if (_this.state.draggedThumbIndex === -1 &&\n                _this.state.draggedTrackPos[0] === -1 &&\n                _this.state.draggedTrackPos[1] === -1)\n                return null;\n            _this.setState({ draggedThumbIndex: -1, draggedTrackPos: [-1, -1] }, function () {\n                _this.fireOnFinalChange();\n            });\n        };\n        _this.fireOnFinalChange = function () {\n            _this.setState({ isChanged: false });\n            var _a = _this.props, onFinalChange = _a.onFinalChange, values = _a.values;\n            if (onFinalChange) {\n                onFinalChange(values);\n            }\n        };\n        _this.updateMarkRefs = function (props) {\n            if (!props.renderMark) {\n                // don't create mark refs unless we are rendering marks\n                _this.numOfMarks = undefined;\n                _this.markRefs = undefined;\n                return;\n            }\n            _this.numOfMarks = (props.max - props.min) / _this.props.step;\n            _this.markRefs = [];\n            for (var i = 0; i < _this.numOfMarks + 1; i++) {\n                _this.markRefs[i] = React.createRef();\n            }\n        };\n        _this.calculateMarkOffsets = function () {\n            if (!_this.props.renderMark ||\n                !_this.trackRef ||\n                !_this.numOfMarks ||\n                !_this.markRefs ||\n                _this.trackRef.current === null)\n                return;\n            var elStyles = window.getComputedStyle(_this.trackRef.current);\n            var trackWidth = parseInt(elStyles.width, 10);\n            var trackHeight = parseInt(elStyles.height, 10);\n            var paddingLeft = parseInt(elStyles.paddingLeft, 10);\n            var paddingTop = parseInt(elStyles.paddingTop, 10);\n            var res = [];\n            for (var i = 0; i < _this.numOfMarks + 1; i++) {\n                var markHeight = 9999;\n                var markWidth = 9999;\n                if (_this.markRefs[i].current) {\n                    var markRect = _this.markRefs[i].current.getBoundingClientRect();\n                    markHeight = markRect.height;\n                    markWidth = markRect.width;\n                }\n                if (_this.props.direction === types_1.Direction.Left ||\n                    _this.props.direction === types_1.Direction.Right) {\n                    res.push([\n                        Math.round((trackWidth / _this.numOfMarks) * i + paddingLeft - markWidth / 2),\n                        -Math.round((markHeight - trackHeight) / 2),\n                    ]);\n                }\n                else {\n                    res.push([\n                        Math.round((trackHeight / _this.numOfMarks) * i + paddingTop - markHeight / 2),\n                        -Math.round((markWidth - trackWidth) / 2),\n                    ]);\n                }\n            }\n            _this.setState({ markOffsets: res });\n        };\n        if (props.step === 0) {\n            throw new Error('\"step\" property should be a positive number');\n        }\n        _this.schdOnMouseMove = (0, utils_1.schd)(_this.onMouseMove);\n        _this.schdOnTouchMove = (0, utils_1.schd)(_this.onTouchMove);\n        _this.schdOnEnd = (0, utils_1.schd)(_this.onEnd);\n        _this.thumbRefs = props.values.map(function () { return React.createRef(); });\n        _this.updateMarkRefs(props);\n        return _this;\n    }\n    Range.prototype.componentDidMount = function () {\n        var _this = this;\n        var _a = this.props, values = _a.values, min = _a.min, step = _a.step;\n        this.resizeObserver = window.ResizeObserver\n            ? new window.ResizeObserver(this.onResize)\n            : {\n                observe: function () { return window.addEventListener(\"resize\", _this.onResize); },\n                unobserve: function () { return window.removeEventListener(\"resize\", _this.onResize); },\n            };\n        document.addEventListener(\"touchstart\", this.onMouseOrTouchStart, {\n            passive: false,\n        });\n        document.addEventListener(\"mousedown\", this.onMouseOrTouchStart, {\n            passive: false,\n        });\n        !this.props.allowOverlap && (0, utils_1.checkInitialOverlap)(this.props.values);\n        this.props.values.forEach(function (value) {\n            return (0, utils_1.checkBoundaries)(value, _this.props.min, _this.props.max);\n        });\n        this.resizeObserver.observe(this.trackRef.current);\n        (0, utils_1.translateThumbs)(this.getThumbs(), this.getOffsets(), this.props.rtl);\n        this.calculateMarkOffsets();\n        values.forEach(function (value) {\n            if (!(0, utils_1.isStepDivisible)(min, value, step)) {\n                console.warn(\"The `values` property is in conflict with the current `step`, `min`, and `max` properties. Please provide values that are accessible using the min, max, and step values.\");\n            }\n        });\n    };\n    Range.prototype.componentDidUpdate = function (prevProps, prevState) {\n        var _a = this.props, max = _a.max, min = _a.min, step = _a.step, values = _a.values, rtl = _a.rtl;\n        if (prevProps.max !== max ||\n            prevProps.min !== min ||\n            prevProps.step !== step) {\n            this.updateMarkRefs(this.props);\n        }\n        (0, utils_1.translateThumbs)(this.getThumbs(), this.getOffsets(), rtl);\n        // ensure offsets are calculated when the refs for the marks have been created\n        // and those refs have been mounted to the dom\n        // on the state update in calculateOffsets with new markOffsets are calculated\n        if (prevProps.max !== max ||\n            prevProps.min !== min ||\n            prevProps.step !== step ||\n            prevState.markOffsets.length !== this.state.markOffsets.length) {\n            this.calculateMarkOffsets();\n            values.forEach(function (value) {\n                if (!(0, utils_1.isStepDivisible)(min, value, step)) {\n                    console.warn(\"The `values` property is in conflict with the current `step`, `min`, and `max` properties. Please provide values that are accessible using the min, max, and step values.\");\n                }\n            });\n        }\n    };\n    Range.prototype.componentWillUnmount = function () {\n        var options = {\n            passive: false,\n        };\n        document.removeEventListener(\"mousedown\", this.onMouseOrTouchStart, options);\n        // These need to be removed!!\n        document.removeEventListener(\"mousemove\", this.schdOnMouseMove);\n        document.removeEventListener(\"touchmove\", this.schdOnTouchMove);\n        document.removeEventListener(\"touchstart\", this.onMouseOrTouchStart);\n        document.removeEventListener(\"mouseup\", this.schdOnEnd);\n        document.removeEventListener(\"touchend\", this.schdOnEnd);\n        this.resizeObserver.unobserve(this.trackRef.current);\n    };\n    Range.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, label = _a.label, labelledBy = _a.labelledBy, renderTrack = _a.renderTrack, renderThumb = _a.renderThumb, _b = _a.renderMark, renderMark = _b === void 0 ? function () { return null; } : _b, values = _a.values, min = _a.min, max = _a.max, allowOverlap = _a.allowOverlap, disabled = _a.disabled;\n        var _c = this.state, draggedThumbIndex = _c.draggedThumbIndex, thumbZIndexes = _c.thumbZIndexes, markOffsets = _c.markOffsets;\n        return renderTrack({\n            props: {\n                style: {\n                    // creates stacking context that prevents z-index applied to thumbs\n                    // interfere with other elements\n                    transform: \"scale(1)\",\n                    cursor: draggedThumbIndex > -1\n                        ? \"grabbing\"\n                        : this.props.draggableTrack\n                            ? (0, utils_1.isVertical)(this.props.direction)\n                                ? \"ns-resize\"\n                                : \"ew-resize\"\n                            : values.length === 1 && !disabled\n                                ? \"pointer\"\n                                : \"inherit\",\n                },\n                onMouseDown: disabled ? utils_1.voidFn : this.onMouseDownTrack,\n                onTouchStart: disabled ? utils_1.voidFn : this.onTouchStartTrack,\n                ref: this.trackRef,\n            },\n            isDragged: this.state.draggedThumbIndex > -1,\n            disabled: disabled,\n            children: __spreadArray(__spreadArray([], markOffsets.map(function (offset, index, arr) {\n                return renderMark({\n                    props: {\n                        style: _this.props.direction === types_1.Direction.Left ||\n                            _this.props.direction === types_1.Direction.Right\n                            ? {\n                                position: \"absolute\",\n                                left: \"\".concat(offset[0], \"px\"),\n                                marginTop: \"\".concat(offset[1], \"px\"),\n                            }\n                            : {\n                                position: \"absolute\",\n                                top: \"\".concat(offset[0], \"px\"),\n                                marginLeft: \"\".concat(offset[1], \"px\"),\n                            },\n                        key: \"mark\".concat(index),\n                        ref: _this.markRefs[index],\n                    },\n                    index: index,\n                });\n            }), true), values.map(function (value, index) {\n                var isDragged = _this.state.draggedThumbIndex === index;\n                return renderThumb({\n                    index: index,\n                    value: value,\n                    isDragged: isDragged,\n                    props: {\n                        style: {\n                            position: \"absolute\",\n                            zIndex: thumbZIndexes[index],\n                            cursor: disabled ? \"inherit\" : isDragged ? \"grabbing\" : \"grab\",\n                            userSelect: \"none\",\n                            touchAction: \"none\",\n                            WebkitUserSelect: \"none\",\n                            MozUserSelect: \"none\",\n                            msUserSelect: \"none\",\n                        },\n                        key: index,\n                        tabIndex: disabled ? undefined : 0,\n                        \"aria-valuemax\": allowOverlap ? max : values[index + 1] || max,\n                        \"aria-valuemin\": allowOverlap ? min : values[index - 1] || min,\n                        \"aria-valuenow\": value,\n                        draggable: false,\n                        ref: _this.thumbRefs[index],\n                        \"aria-label\": label,\n                        \"aria-labelledby\": labelledBy,\n                        role: \"slider\",\n                        onKeyDown: disabled ? utils_1.voidFn : _this.onKeyDown,\n                        onKeyUp: disabled ? utils_1.voidFn : _this.onKeyUp,\n                    },\n                });\n            }), true),\n        });\n    };\n    Range.defaultProps = {\n        label: \"Accessibility label\",\n        labelledBy: null,\n        step: 1,\n        direction: types_1.Direction.Right,\n        rtl: false,\n        disabled: false,\n        allowOverlap: false,\n        draggableTrack: false,\n        min: 0,\n        max: 100,\n    };\n    return Range;\n}(React.Component));\nexports[\"default\"] = Range;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL1JhbmdlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLG1CQUFPLENBQUMsaUdBQU87QUFDeEMsY0FBYyxtQkFBTyxDQUFDLDhEQUFTO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyw4REFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLFdBQVc7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIi9ob21lL2tpdC93b3JrLzF6YWthekR1YmFpL25vZGVfbW9kdWxlcy9yZWFjdC1yYW5nZS9saWIvUmFuZ2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xudmFyIElOQ1JFQVNFX0tFWVMgPSBbXCJBcnJvd1JpZ2h0XCIsIFwiQXJyb3dVcFwiLCBcImtcIiwgXCJQYWdlVXBcIl07XG52YXIgREVDUkVBU0VfS0VZUyA9IFtcIkFycm93TGVmdFwiLCBcIkFycm93RG93blwiLCBcImpcIiwgXCJQYWdlRG93blwiXTtcbnZhciBSYW5nZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmFuZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmFuZ2UocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRyYWNrUmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLnRodW1iUmVmcyA9IFtdO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGRyYWdnZWRUcmFja1BvczogWy0xLCAtMV0sXG4gICAgICAgICAgICBkcmFnZ2VkVGh1bWJJbmRleDogLTEsXG4gICAgICAgICAgICB0aHVtYlpJbmRleGVzOiBuZXcgQXJyYXkoX3RoaXMucHJvcHMudmFsdWVzLmxlbmd0aCkuZmlsbCgwKS5tYXAoZnVuY3Rpb24gKHQsIGkpIHsgcmV0dXJuIGk7IH0pLFxuICAgICAgICAgICAgaXNDaGFuZ2VkOiBmYWxzZSxcbiAgICAgICAgICAgIG1hcmtPZmZzZXRzOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0T2Zmc2V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkaXJlY3Rpb24gPSBfYS5kaXJlY3Rpb24sIHZhbHVlcyA9IF9hLnZhbHVlcywgbWluID0gX2EubWluLCBtYXggPSBfYS5tYXg7XG4gICAgICAgICAgICB2YXIgdHJhY2tFbGVtZW50ID0gX3RoaXMudHJhY2tSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmICghdHJhY2tFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTm8gdHJhY2sgZWxlbWVudCBmb3VuZC5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRyYWNrUmVjdCA9IHRyYWNrRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhciB0cmFja1BhZGRpbmcgPSAoMCwgdXRpbHNfMS5nZXRQYWRkaW5nQW5kQm9yZGVyKSh0cmFja0VsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldFRodW1icygpLm1hcChmdW5jdGlvbiAodGh1bWIsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRodW1iT2Zmc2V0cyA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICAgICAgICAgIHZhciB0aHVtYlJlY3QgPSB0aHVtYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgdGh1bWJNYXJnaW5zID0gKDAsIHV0aWxzXzEuZ2V0TWFyZ2luKSh0aHVtYik7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5SaWdodDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy54ID0gKHRodW1iTWFyZ2lucy5sZWZ0ICsgdHJhY2tQYWRkaW5nLmxlZnQpICogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCh0aHVtYlJlY3QuaGVpZ2h0IC0gdHJhY2tSZWN0LmhlaWdodCkgLyAyICsgdHJhY2tQYWRkaW5nLnRvcCkgKiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy54ICs9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tSZWN0LndpZHRoICogKDAsIHV0aWxzXzEucmVsYXRpdmVWYWx1ZSkodmFsdWVzW2luZGV4XSwgbWluLCBtYXgpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJSZWN0LndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aHVtYk9mZnNldHM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uTGVmdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy54ID0gKHRodW1iTWFyZ2lucy5yaWdodCArIHRyYWNrUGFkZGluZy5yaWdodCkgKiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy55ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHRodW1iUmVjdC5oZWlnaHQgLSB0cmFja1JlY3QuaGVpZ2h0KSAvIDIgKyB0cmFja1BhZGRpbmcudG9wKSAqIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnggKz1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja1JlY3Qud2lkdGggLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja1JlY3Qud2lkdGggKiAoMCwgdXRpbHNfMS5yZWxhdGl2ZVZhbHVlKSh2YWx1ZXNbaW5kZXhdLCBtaW4sIG1heCkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYlJlY3Qud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRodW1iT2Zmc2V0cztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5VcDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy54ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHRodW1iUmVjdC53aWR0aCAtIHRyYWNrUmVjdC53aWR0aCkgLyAyICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJNYXJnaW5zLmxlZnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja1BhZGRpbmcubGVmdCkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy55ID0gLXRyYWNrUGFkZGluZy5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnkgKz1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja1JlY3QuaGVpZ2h0IC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tSZWN0LmhlaWdodCAqICgwLCB1dGlsc18xLnJlbGF0aXZlVmFsdWUpKHZhbHVlc1tpbmRleF0sIG1pbiwgbWF4KSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iUmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRodW1iT2Zmc2V0cztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5Eb3duOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgodGh1bWJSZWN0LndpZHRoIC0gdHJhY2tSZWN0LndpZHRoKSAvIDIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk1hcmdpbnMubGVmdCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrUGFkZGluZy5sZWZ0KSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnkgPSAtdHJhY2tQYWRkaW5nLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueSArPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrUmVjdC5oZWlnaHQgKiAoMCwgdXRpbHNfMS5yZWxhdGl2ZVZhbHVlKSh2YWx1ZXNbaW5kZXhdLCBtaW4sIG1heCkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYlJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aHVtYk9mZnNldHM7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuYXNzZXJ0VW5yZWFjaGFibGUpKGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldFRodW1icyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy50cmFja1JlZiAmJiBfdGhpcy50cmFja1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oX3RoaXMudHJhY2tSZWYuY3VycmVudC5jaGlsZHJlbikuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwuaGFzQXR0cmlidXRlKFwiYXJpYS12YWx1ZW5vd1wiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk5vIHRodW1icyBmb3VuZCBpbiB0aGUgdHJhY2sgY29udGFpbmVyLiBEaWQgeW91IGZvcmdldCB0byBwYXNzICYgc3ByZWFkIHRoZSBgcHJvcHNgIHBhcmFtIGluIHJlbmRlclRyYWNrP1wiKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0VGFyZ2V0SW5kZXggPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldFRodW1icygpLmZpbmRJbmRleChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkID09PSBlLnRhcmdldCB8fCBjaGlsZC5jb250YWlucyhlLnRhcmdldCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5hZGRUb3VjaEV2ZW50cyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIF90aGlzLnNjaGRPblRvdWNoTW92ZSwge1xuICAgICAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgX3RoaXMuc2NoZE9uRW5kLCB7XG4gICAgICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCBfdGhpcy5zY2hkT25FbmQsIHtcbiAgICAgICAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5hZGRNb3VzZUV2ZW50cyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIF90aGlzLnNjaGRPbk1vdXNlTW92ZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBfdGhpcy5zY2hkT25FbmQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbk1vdXNlRG93blRyYWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChlLmJ1dHRvbiAhPT0gMCB8fCAoMCwgdXRpbHNfMS5pc0lPUykoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBlLnBlcnNpc3QoKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIF90aGlzLmFkZE1vdXNlRXZlbnRzKGUubmF0aXZlRXZlbnQpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnZhbHVlcy5sZW5ndGggPiAxICYmIF90aGlzLnByb3BzLmRyYWdnYWJsZVRyYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnRodW1iUmVmcy5zb21lKGZ1bmN0aW9uICh0aHVtYlJlZikgeyB2YXIgX2E7IHJldHVybiAoX2EgPSB0aHVtYlJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGFpbnMoZS50YXJnZXQpOyB9KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBkcmFnZ2luZyB0aGUgd2hvbGUgdHJhY2tcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdnZWRUcmFja1BvczogW2UuY2xpZW50WCwgZS5jbGllbnRZXSxcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5vbk1vdmUoZS5jbGllbnRYLCBlLmNsaWVudFkpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgaW5kZXggb2YgdGhlIHRodW1iIHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgcGxhY2Ugd2hlcmUgdGhlIHRyYWNrIGlzIGNsaWNrZWRcbiAgICAgICAgICAgICAgICB2YXIgZHJhZ2dlZFRodW1iSW5kZXggPSAoMCwgdXRpbHNfMS5nZXRDbG9zZXN0VGh1bWJJbmRleCkoX3RoaXMudGh1bWJSZWZzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5jdXJyZW50OyB9KSwgZS5jbGllbnRYLCBlLmNsaWVudFksIF90aGlzLnByb3BzLmRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgdGh1bWIgd2hpY2ggaXMgY2xvc2VzdCB0byB0aGUgcGxhY2Ugd2hlcmUgdGhlIHRyYWNrIGlzIGNsaWNrZWRcbiAgICAgICAgICAgICAgICAoX2EgPSBfdGhpcy50aHVtYlJlZnNbZHJhZ2dlZFRodW1iSW5kZXhdLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZFRodW1iSW5kZXg6IGRyYWdnZWRUaHVtYkluZGV4LFxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uTW92ZShlLmNsaWVudFgsIGUuY2xpZW50WSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICgwLCB1dGlsc18xLnRyYW5zbGF0ZVRodW1icykoX3RoaXMuZ2V0VGh1bWJzKCksIF90aGlzLmdldE9mZnNldHMoKSwgX3RoaXMucHJvcHMucnRsKTtcbiAgICAgICAgICAgIF90aGlzLmNhbGN1bGF0ZU1hcmtPZmZzZXRzKCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uVG91Y2hTdGFydFRyYWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGUucGVyc2lzdCgpO1xuICAgICAgICAgICAgX3RoaXMuYWRkVG91Y2hFdmVudHMoZS5uYXRpdmVFdmVudCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMudmFsdWVzLmxlbmd0aCA+IDEgJiYgX3RoaXMucHJvcHMuZHJhZ2dhYmxlVHJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudGh1bWJSZWZzLnNvbWUoZnVuY3Rpb24gKHRodW1iUmVmKSB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRodW1iUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucyhlLnRhcmdldCk7IH0pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGRyYWdnaW5nIHRoZSB3aG9sZSB0cmFja1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZFRyYWNrUG9zOiBbZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZXSxcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5vbk1vdmUoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGluZGV4IG9mIHRoZSB0aHVtYiB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIHBsYWNlIHdoZXJlIHRoZSB0cmFjayBpcyBjbGlja2VkXG4gICAgICAgICAgICAgICAgdmFyIGRyYWdnZWRUaHVtYkluZGV4ID0gKDAsIHV0aWxzXzEuZ2V0Q2xvc2VzdFRodW1iSW5kZXgpKF90aGlzLnRodW1iUmVmcy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuY3VycmVudDsgfSksIGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSwgX3RoaXMucHJvcHMuZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHRoZSB0aHVtYiB3aGljaCBpcyBjbG9zZXN0IHRvIHRoZSBwbGFjZSB3aGVyZSB0aGUgdHJhY2sgaXMgY2xpY2tlZFxuICAgICAgICAgICAgICAgIChfYSA9IF90aGlzLnRodW1iUmVmc1tkcmFnZ2VkVGh1bWJJbmRleF0uY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkVGh1bWJJbmRleDogZHJhZ2dlZFRodW1iSW5kZXgsXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25Nb3ZlKGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbk1vdXNlT3JUb3VjaFN0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5kaXNhYmxlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaXNUb3VjaCA9ICgwLCB1dGlsc18xLmlzVG91Y2hFdmVudCkoZSk7XG4gICAgICAgICAgICBpZiAoIWlzVG91Y2ggJiYgZS5idXR0b24gIT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMuZ2V0VGFyZ2V0SW5kZXgoZSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWRkVG91Y2hFdmVudHMoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGRNb3VzZUV2ZW50cyhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBkcmFnZ2VkVGh1bWJJbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgdGh1bWJaSW5kZXhlczogX3RoaXMuc3RhdGUudGh1bWJaSW5kZXhlcy5tYXAoZnVuY3Rpb24gKHQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RoaXMuc3RhdGUudGh1bWJaSW5kZXhlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgPD0gX3RoaXMuc3RhdGUudGh1bWJaSW5kZXhlc1tpbmRleF0gPyB0IDogdCAtIDE7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgX3RoaXMub25Nb3ZlKGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25Ub3VjaE1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgX3RoaXMub25Nb3ZlKGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uS2V5RG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgdmFsdWVzID0gX2EudmFsdWVzLCBvbkNoYW5nZSA9IF9hLm9uQ2hhbmdlLCBzdGVwID0gX2Euc3RlcCwgcnRsID0gX2EucnRsLCBkaXJlY3Rpb24gPSBfYS5kaXJlY3Rpb247XG4gICAgICAgICAgICB2YXIgaXNDaGFuZ2VkID0gX3RoaXMuc3RhdGUuaXNDaGFuZ2VkO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMuZ2V0VGFyZ2V0SW5kZXgoZS5uYXRpdmVFdmVudCk7XG4gICAgICAgICAgICB2YXIgaW52ZXJ0ZXIgPSBydGwgfHwgZGlyZWN0aW9uID09PSB0eXBlc18xLkRpcmVjdGlvbi5MZWZ0IHx8IGRpcmVjdGlvbiA9PT0gdHlwZXNfMS5EaXJlY3Rpb24uRG93blxuICAgICAgICAgICAgICAgID8gLTFcbiAgICAgICAgICAgICAgICA6IDE7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChJTkNSRUFTRV9LRVlTLmluY2x1ZGVzKGUua2V5KSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdnZWRUaHVtYkluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaXNDaGFuZ2VkOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9uQ2hhbmdlKCgwLCB1dGlsc18xLnJlcGxhY2VBdCkodmFsdWVzLCBpbmRleCwgX3RoaXMubm9ybWFsaXplVmFsdWUodmFsdWVzW2luZGV4XSArIGludmVydGVyICogKGUua2V5ID09PSBcIlBhZ2VVcFwiID8gc3RlcCAqIDEwIDogc3RlcCksIGluZGV4KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoREVDUkVBU0VfS0VZUy5pbmNsdWRlcyhlLmtleSkpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkVGh1bWJJbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGlzQ2hhbmdlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvbkNoYW5nZSgoMCwgdXRpbHNfMS5yZXBsYWNlQXQpKHZhbHVlcywgaW5kZXgsIF90aGlzLm5vcm1hbGl6ZVZhbHVlKHZhbHVlc1tpbmRleF0gLVxuICAgICAgICAgICAgICAgICAgICBpbnZlcnRlciAqIChlLmtleSA9PT0gXCJQYWdlRG93blwiID8gc3RlcCAqIDEwIDogc3RlcCksIGluZGV4KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZS5rZXkgPT09IFwiVGFiXCIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGRyYWdnZWRUaHVtYkluZGV4OiAtMSB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGtleSBwcmVzc2VkIHdoZW4gdGh1bWIgd2FzIG1vdmluZywgZmlyZSBvbkZpbmFsQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmZpcmVPbkZpbmFsQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmlyZU9uRmluYWxDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uS2V5VXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGlzQ2hhbmdlZCA9IF90aGlzLnN0YXRlLmlzQ2hhbmdlZDtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBkcmFnZ2VkVGh1bWJJbmRleDogLTEsXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5maXJlT25GaW5hbENoYW5nZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbk1vdmUgPSBmdW5jdGlvbiAoY2xpZW50WCwgY2xpZW50WSkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuc3RhdGUsIGRyYWdnZWRUaHVtYkluZGV4ID0gX2EuZHJhZ2dlZFRodW1iSW5kZXgsIGRyYWdnZWRUcmFja1BvcyA9IF9hLmRyYWdnZWRUcmFja1BvcztcbiAgICAgICAgICAgIHZhciBfYiA9IF90aGlzLnByb3BzLCBkaXJlY3Rpb24gPSBfYi5kaXJlY3Rpb24sIG1pbiA9IF9iLm1pbiwgbWF4ID0gX2IubWF4LCBvbkNoYW5nZSA9IF9iLm9uQ2hhbmdlLCB2YWx1ZXMgPSBfYi52YWx1ZXMsIHN0ZXAgPSBfYi5zdGVwLCBydGwgPSBfYi5ydGw7XG4gICAgICAgICAgICBpZiAoZHJhZ2dlZFRodW1iSW5kZXggPT09IC0xICYmXG4gICAgICAgICAgICAgICAgZHJhZ2dlZFRyYWNrUG9zWzBdID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIGRyYWdnZWRUcmFja1Bvc1sxXSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgdHJhY2tFbGVtZW50ID0gX3RoaXMudHJhY2tSZWYuY3VycmVudDtcbiAgICAgICAgICAgIC8vIElmIGNvbXBvbmVudCB3YXMgY2xvc2VkIGRvd24gcHJlbWF0dXJlbHksIEEgbGFzdCBvbk1vdmUgY291bGQgYmUgdHJpZ2dlcmVkIGJhc2VkIG9uIHJlcXVlc3RBbmltYXRpb25GcmFtZSgpXG4gICAgICAgICAgICBpZiAoIXRyYWNrRWxlbWVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHZhciB0cmFja1JlY3QgPSB0cmFja0VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgdHJhY2tMZW5ndGggPSAoMCwgdXRpbHNfMS5pc1ZlcnRpY2FsKShkaXJlY3Rpb24pXG4gICAgICAgICAgICAgICAgPyB0cmFja1JlY3QuaGVpZ2h0XG4gICAgICAgICAgICAgICAgOiB0cmFja1JlY3Qud2lkdGg7XG4gICAgICAgICAgICBpZiAoZHJhZ2dlZFRyYWNrUG9zWzBdICE9PSAtMSAmJiBkcmFnZ2VkVHJhY2tQb3NbMV0gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIGhvdyBtdWNoIGl0IG1vdmVkIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZVxuICAgICAgICAgICAgICAgIHZhciBkWCA9IGNsaWVudFggLSBkcmFnZ2VkVHJhY2tQb3NbMF07XG4gICAgICAgICAgICAgICAgdmFyIGRZID0gY2xpZW50WSAtIGRyYWdnZWRUcmFja1Bvc1sxXTtcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGRlbHRhIG9mIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgIHZhciBkZWx0YVZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLlJpZ2h0OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLkxlZnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVZhbHVlID0gKGRYIC8gdHJhY2tMZW5ndGgpICogKG1heCAtIG1pbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5Eb3duOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLlVwOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFWYWx1ZSA9IChkWSAvIHRyYWNrTGVuZ3RoKSAqIChtYXggLSBtaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnRVbnJlYWNoYWJsZSkoZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaW52ZXJ0IGZvciBSVExcbiAgICAgICAgICAgICAgICBpZiAocnRsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhVmFsdWUgKj0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YVZhbHVlKSA+PSBzdGVwIC8gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGp1c3QgZGVsdGEgc28gaXQgZml0cyBpbnRvIHRoZSByYW5nZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLnRodW1iUmVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZXNbaV0gPT09IG1heCAmJiBNYXRoLnNpZ24oZGVsdGFWYWx1ZSkgPT09IDEpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZhbHVlc1tpXSA9PT0gbWluICYmIE1hdGguc2lnbihkZWx0YVZhbHVlKSA9PT0gLTEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aHVtYlZhbHVlID0gdmFsdWVzW2ldICsgZGVsdGFWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aHVtYlZhbHVlID4gbWF4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhVmFsdWUgPSBtYXggLSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aHVtYlZhbHVlIDwgbWluKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhVmFsdWUgPSBtaW4gLSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBkZWx0YSB0byBlYWNoIHRodW1iXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZXMgPSB2YWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMudGh1bWJSZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZXMgPSAoMCwgdXRpbHNfMS5yZXBsYWNlQXQpKG5ld1ZhbHVlcywgaSwgX3RoaXMubm9ybWFsaXplVmFsdWUodmFsdWVzW2ldICsgZGVsdGFWYWx1ZSwgaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnZWRUcmFja1BvczogW2NsaWVudFgsIGNsaWVudFldLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UobmV3VmFsdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uUmlnaHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChjbGllbnRYIC0gdHJhY2tSZWN0LmxlZnQpIC8gdHJhY2tMZW5ndGgpICogKG1heCAtIG1pbikgKyBtaW47XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5MZWZ0OlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgodHJhY2tMZW5ndGggLSAoY2xpZW50WCAtIHRyYWNrUmVjdC5sZWZ0KSkgLyB0cmFja0xlbmd0aCkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWF4IC0gbWluKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLkRvd246XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChjbGllbnRZIC0gdHJhY2tSZWN0LnRvcCkgLyB0cmFja0xlbmd0aCkgKiAobWF4IC0gbWluKSArIG1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLlVwOlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgodHJhY2tMZW5ndGggLSAoY2xpZW50WSAtIHRyYWNrUmVjdC50b3ApKSAvIHRyYWNrTGVuZ3RoKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXggLSBtaW4pICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnRVbnJlYWNoYWJsZSkoZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaW52ZXJ0IGZvciBSVExcbiAgICAgICAgICAgICAgICBpZiAocnRsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gbWF4ICsgbWluIC0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh2YWx1ZXNbZHJhZ2dlZFRodW1iSW5kZXhdIC0gbmV3VmFsdWUpID49IHN0ZXAgLyAyKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKCgwLCB1dGlsc18xLnJlcGxhY2VBdCkodmFsdWVzLCBkcmFnZ2VkVGh1bWJJbmRleCwgX3RoaXMubm9ybWFsaXplVmFsdWUobmV3VmFsdWUsIGRyYWdnZWRUaHVtYkluZGV4KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubm9ybWFsaXplVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgbWluID0gX2EubWluLCBtYXggPSBfYS5tYXgsIHN0ZXAgPSBfYS5zdGVwLCBhbGxvd092ZXJsYXAgPSBfYS5hbGxvd092ZXJsYXAsIHZhbHVlcyA9IF9hLnZhbHVlcztcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5ub3JtYWxpemVWYWx1ZSkodmFsdWUsIGluZGV4LCBtaW4sIG1heCwgc3RlcCwgYWxsb3dPdmVybGFwLCB2YWx1ZXMpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIF90aGlzLnNjaGRPbk1vdXNlTW92ZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIF90aGlzLnNjaGRPblRvdWNoTW92ZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBfdGhpcy5zY2hkT25FbmQpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIF90aGlzLnNjaGRPbkVuZCk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgX3RoaXMuc2NoZE9uRW5kKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5kcmFnZ2VkVGh1bWJJbmRleCA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZS5kcmFnZ2VkVHJhY2tQb3NbMF0gPT09IC0xICYmXG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUuZHJhZ2dlZFRyYWNrUG9zWzFdID09PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgZHJhZ2dlZFRodW1iSW5kZXg6IC0xLCBkcmFnZ2VkVHJhY2tQb3M6IFstMSwgLTFdIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5maXJlT25GaW5hbENoYW5nZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmZpcmVPbkZpbmFsQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBpc0NoYW5nZWQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIG9uRmluYWxDaGFuZ2UgPSBfYS5vbkZpbmFsQ2hhbmdlLCB2YWx1ZXMgPSBfYS52YWx1ZXM7XG4gICAgICAgICAgICBpZiAob25GaW5hbENoYW5nZSkge1xuICAgICAgICAgICAgICAgIG9uRmluYWxDaGFuZ2UodmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMudXBkYXRlTWFya1JlZnMgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgICAgIGlmICghcHJvcHMucmVuZGVyTWFyaykge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGNyZWF0ZSBtYXJrIHJlZnMgdW5sZXNzIHdlIGFyZSByZW5kZXJpbmcgbWFya3NcbiAgICAgICAgICAgICAgICBfdGhpcy5udW1PZk1hcmtzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIF90aGlzLm1hcmtSZWZzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLm51bU9mTWFya3MgPSAocHJvcHMubWF4IC0gcHJvcHMubWluKSAvIF90aGlzLnByb3BzLnN0ZXA7XG4gICAgICAgICAgICBfdGhpcy5tYXJrUmVmcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5udW1PZk1hcmtzICsgMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubWFya1JlZnNbaV0gPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuY2FsY3VsYXRlTWFya09mZnNldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLnByb3BzLnJlbmRlck1hcmsgfHxcbiAgICAgICAgICAgICAgICAhX3RoaXMudHJhY2tSZWYgfHxcbiAgICAgICAgICAgICAgICAhX3RoaXMubnVtT2ZNYXJrcyB8fFxuICAgICAgICAgICAgICAgICFfdGhpcy5tYXJrUmVmcyB8fFxuICAgICAgICAgICAgICAgIF90aGlzLnRyYWNrUmVmLmN1cnJlbnQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGVsU3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoX3RoaXMudHJhY2tSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB2YXIgdHJhY2tXaWR0aCA9IHBhcnNlSW50KGVsU3R5bGVzLndpZHRoLCAxMCk7XG4gICAgICAgICAgICB2YXIgdHJhY2tIZWlnaHQgPSBwYXJzZUludChlbFN0eWxlcy5oZWlnaHQsIDEwKTtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nTGVmdCA9IHBhcnNlSW50KGVsU3R5bGVzLnBhZGRpbmdMZWZ0LCAxMCk7XG4gICAgICAgICAgICB2YXIgcGFkZGluZ1RvcCA9IHBhcnNlSW50KGVsU3R5bGVzLnBhZGRpbmdUb3AsIDEwKTtcbiAgICAgICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMubnVtT2ZNYXJrcyArIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBtYXJrSGVpZ2h0ID0gOTk5OTtcbiAgICAgICAgICAgICAgICB2YXIgbWFya1dpZHRoID0gOTk5OTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMubWFya1JlZnNbaV0uY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFya1JlY3QgPSBfdGhpcy5tYXJrUmVmc1tpXS5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBtYXJrSGVpZ2h0ID0gbWFya1JlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBtYXJrV2lkdGggPSBtYXJrUmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmRpcmVjdGlvbiA9PT0gdHlwZXNfMS5EaXJlY3Rpb24uTGVmdCB8fFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5kaXJlY3Rpb24gPT09IHR5cGVzXzEuRGlyZWN0aW9uLlJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQoKHRyYWNrV2lkdGggLyBfdGhpcy5udW1PZk1hcmtzKSAqIGkgKyBwYWRkaW5nTGVmdCAtIG1hcmtXaWR0aCAvIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLU1hdGgucm91bmQoKG1hcmtIZWlnaHQgLSB0cmFja0hlaWdodCkgLyAyKSxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKCh0cmFja0hlaWdodCAvIF90aGlzLm51bU9mTWFya3MpICogaSArIHBhZGRpbmdUb3AgLSBtYXJrSGVpZ2h0IC8gMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAtTWF0aC5yb3VuZCgobWFya1dpZHRoIC0gdHJhY2tXaWR0aCkgLyAyKSxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBtYXJrT2Zmc2V0czogcmVzIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocHJvcHMuc3RlcCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInN0ZXBcIiBwcm9wZXJ0eSBzaG91bGQgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5zY2hkT25Nb3VzZU1vdmUgPSAoMCwgdXRpbHNfMS5zY2hkKShfdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgICAgIF90aGlzLnNjaGRPblRvdWNoTW92ZSA9ICgwLCB1dGlsc18xLnNjaGQpKF90aGlzLm9uVG91Y2hNb3ZlKTtcbiAgICAgICAgX3RoaXMuc2NoZE9uRW5kID0gKDAsIHV0aWxzXzEuc2NoZCkoX3RoaXMub25FbmQpO1xuICAgICAgICBfdGhpcy50aHVtYlJlZnMgPSBwcm9wcy52YWx1ZXMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJlYWN0LmNyZWF0ZVJlZigpOyB9KTtcbiAgICAgICAgX3RoaXMudXBkYXRlTWFya1JlZnMocHJvcHMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJhbmdlLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgdmFsdWVzID0gX2EudmFsdWVzLCBtaW4gPSBfYS5taW4sIHN0ZXAgPSBfYS5zdGVwO1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gd2luZG93LlJlc2l6ZU9ic2VydmVyXG4gICAgICAgICAgICA/IG5ldyB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIodGhpcy5vblJlc2l6ZSlcbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIG9ic2VydmU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIF90aGlzLm9uUmVzaXplKTsgfSxcbiAgICAgICAgICAgICAgICB1bm9ic2VydmU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIF90aGlzLm9uUmVzaXplKTsgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMub25Nb3VzZU9yVG91Y2hTdGFydCwge1xuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMub25Nb3VzZU9yVG91Y2hTdGFydCwge1xuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICAhdGhpcy5wcm9wcy5hbGxvd092ZXJsYXAgJiYgKDAsIHV0aWxzXzEuY2hlY2tJbml0aWFsT3ZlcmxhcCkodGhpcy5wcm9wcy52YWx1ZXMpO1xuICAgICAgICB0aGlzLnByb3BzLnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNoZWNrQm91bmRhcmllcykodmFsdWUsIF90aGlzLnByb3BzLm1pbiwgX3RoaXMucHJvcHMubWF4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnRyYWNrUmVmLmN1cnJlbnQpO1xuICAgICAgICAoMCwgdXRpbHNfMS50cmFuc2xhdGVUaHVtYnMpKHRoaXMuZ2V0VGh1bWJzKCksIHRoaXMuZ2V0T2Zmc2V0cygpLCB0aGlzLnByb3BzLnJ0bCk7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlTWFya09mZnNldHMoKTtcbiAgICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoISgwLCB1dGlsc18xLmlzU3RlcERpdmlzaWJsZSkobWluLCB2YWx1ZSwgc3RlcCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgYHZhbHVlc2AgcHJvcGVydHkgaXMgaW4gY29uZmxpY3Qgd2l0aCB0aGUgY3VycmVudCBgc3RlcGAsIGBtaW5gLCBhbmQgYG1heGAgcHJvcGVydGllcy4gUGxlYXNlIHByb3ZpZGUgdmFsdWVzIHRoYXQgYXJlIGFjY2Vzc2libGUgdXNpbmcgdGhlIG1pbiwgbWF4LCBhbmQgc3RlcCB2YWx1ZXMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJhbmdlLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgbWF4ID0gX2EubWF4LCBtaW4gPSBfYS5taW4sIHN0ZXAgPSBfYS5zdGVwLCB2YWx1ZXMgPSBfYS52YWx1ZXMsIHJ0bCA9IF9hLnJ0bDtcbiAgICAgICAgaWYgKHByZXZQcm9wcy5tYXggIT09IG1heCB8fFxuICAgICAgICAgICAgcHJldlByb3BzLm1pbiAhPT0gbWluIHx8XG4gICAgICAgICAgICBwcmV2UHJvcHMuc3RlcCAhPT0gc3RlcCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNYXJrUmVmcyh0aGlzLnByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgdXRpbHNfMS50cmFuc2xhdGVUaHVtYnMpKHRoaXMuZ2V0VGh1bWJzKCksIHRoaXMuZ2V0T2Zmc2V0cygpLCBydGwpO1xuICAgICAgICAvLyBlbnN1cmUgb2Zmc2V0cyBhcmUgY2FsY3VsYXRlZCB3aGVuIHRoZSByZWZzIGZvciB0aGUgbWFya3MgaGF2ZSBiZWVuIGNyZWF0ZWRcbiAgICAgICAgLy8gYW5kIHRob3NlIHJlZnMgaGF2ZSBiZWVuIG1vdW50ZWQgdG8gdGhlIGRvbVxuICAgICAgICAvLyBvbiB0aGUgc3RhdGUgdXBkYXRlIGluIGNhbGN1bGF0ZU9mZnNldHMgd2l0aCBuZXcgbWFya09mZnNldHMgYXJlIGNhbGN1bGF0ZWRcbiAgICAgICAgaWYgKHByZXZQcm9wcy5tYXggIT09IG1heCB8fFxuICAgICAgICAgICAgcHJldlByb3BzLm1pbiAhPT0gbWluIHx8XG4gICAgICAgICAgICBwcmV2UHJvcHMuc3RlcCAhPT0gc3RlcCB8fFxuICAgICAgICAgICAgcHJldlN0YXRlLm1hcmtPZmZzZXRzLmxlbmd0aCAhPT0gdGhpcy5zdGF0ZS5tYXJrT2Zmc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlTWFya09mZnNldHMoKTtcbiAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICghKDAsIHV0aWxzXzEuaXNTdGVwRGl2aXNpYmxlKShtaW4sIHZhbHVlLCBzdGVwKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgYHZhbHVlc2AgcHJvcGVydHkgaXMgaW4gY29uZmxpY3Qgd2l0aCB0aGUgY3VycmVudCBgc3RlcGAsIGBtaW5gLCBhbmQgYG1heGAgcHJvcGVydGllcy4gUGxlYXNlIHByb3ZpZGUgdmFsdWVzIHRoYXQgYXJlIGFjY2Vzc2libGUgdXNpbmcgdGhlIG1pbiwgbWF4LCBhbmQgc3RlcCB2YWx1ZXMuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5vbk1vdXNlT3JUb3VjaFN0YXJ0LCBvcHRpb25zKTtcbiAgICAgICAgLy8gVGhlc2UgbmVlZCB0byBiZSByZW1vdmVkISFcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLnNjaGRPbk1vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5zY2hkT25Ub3VjaE1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLm9uTW91c2VPclRvdWNoU3RhcnQpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnNjaGRPbkVuZCk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLnNjaGRPbkVuZCk7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHRoaXMudHJhY2tSZWYuY3VycmVudCk7XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBsYWJlbCA9IF9hLmxhYmVsLCBsYWJlbGxlZEJ5ID0gX2EubGFiZWxsZWRCeSwgcmVuZGVyVHJhY2sgPSBfYS5yZW5kZXJUcmFjaywgcmVuZGVyVGh1bWIgPSBfYS5yZW5kZXJUaHVtYiwgX2IgPSBfYS5yZW5kZXJNYXJrLCByZW5kZXJNYXJrID0gX2IgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0gOiBfYiwgdmFsdWVzID0gX2EudmFsdWVzLCBtaW4gPSBfYS5taW4sIG1heCA9IF9hLm1heCwgYWxsb3dPdmVybGFwID0gX2EuYWxsb3dPdmVybGFwLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkO1xuICAgICAgICB2YXIgX2MgPSB0aGlzLnN0YXRlLCBkcmFnZ2VkVGh1bWJJbmRleCA9IF9jLmRyYWdnZWRUaHVtYkluZGV4LCB0aHVtYlpJbmRleGVzID0gX2MudGh1bWJaSW5kZXhlcywgbWFya09mZnNldHMgPSBfYy5tYXJrT2Zmc2V0cztcbiAgICAgICAgcmV0dXJuIHJlbmRlclRyYWNrKHtcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlcyBzdGFja2luZyBjb250ZXh0IHRoYXQgcHJldmVudHMgei1pbmRleCBhcHBsaWVkIHRvIHRodW1ic1xuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcmZlcmUgd2l0aCBvdGhlciBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwic2NhbGUoMSlcIixcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiBkcmFnZ2VkVGh1bWJJbmRleCA+IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiZ3JhYmJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnByb3BzLmRyYWdnYWJsZVRyYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoMCwgdXRpbHNfMS5pc1ZlcnRpY2FsKSh0aGlzLnByb3BzLmRpcmVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIm5zLXJlc2l6ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJldy1yZXNpemVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWVzLmxlbmd0aCA9PT0gMSAmJiAhZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcInBvaW50ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25Nb3VzZURvd246IGRpc2FibGVkID8gdXRpbHNfMS52b2lkRm4gOiB0aGlzLm9uTW91c2VEb3duVHJhY2ssXG4gICAgICAgICAgICAgICAgb25Ub3VjaFN0YXJ0OiBkaXNhYmxlZCA/IHV0aWxzXzEudm9pZEZuIDogdGhpcy5vblRvdWNoU3RhcnRUcmFjayxcbiAgICAgICAgICAgICAgICByZWY6IHRoaXMudHJhY2tSZWYsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNEcmFnZ2VkOiB0aGlzLnN0YXRlLmRyYWdnZWRUaHVtYkluZGV4ID4gLTEsXG4gICAgICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWQsXG4gICAgICAgICAgICBjaGlsZHJlbjogX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBtYXJrT2Zmc2V0cy5tYXAoZnVuY3Rpb24gKG9mZnNldCwgaW5kZXgsIGFycikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJNYXJrKHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBfdGhpcy5wcm9wcy5kaXJlY3Rpb24gPT09IHR5cGVzXzEuRGlyZWN0aW9uLkxlZnQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5kaXJlY3Rpb24gPT09IHR5cGVzXzEuRGlyZWN0aW9uLlJpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IFwiXCIuY29uY2F0KG9mZnNldFswXSwgXCJweFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBcIlwiLmNvbmNhdChvZmZzZXRbMV0sIFwicHhcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IFwiXCIuY29uY2F0KG9mZnNldFswXSwgXCJweFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogXCJcIi5jb25jYXQob2Zmc2V0WzFdLCBcInB4XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwibWFya1wiLmNvbmNhdChpbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgICByZWY6IF90aGlzLm1hcmtSZWZzW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSksIHRydWUpLCB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNEcmFnZ2VkID0gX3RoaXMuc3RhdGUuZHJhZ2dlZFRodW1iSW5kZXggPT09IGluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJUaHVtYih7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpc0RyYWdnZWQ6IGlzRHJhZ2dlZCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IHRodW1iWkluZGV4ZXNbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogZGlzYWJsZWQgPyBcImluaGVyaXRcIiA6IGlzRHJhZ2dlZCA/IFwiZ3JhYmJpbmdcIiA6IFwiZ3JhYlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoQWN0aW9uOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBXZWJraXRVc2VyU2VsZWN0OiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNb3pVc2VyU2VsZWN0OiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc1VzZXJTZWxlY3Q6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJJbmRleDogZGlzYWJsZWQgPyB1bmRlZmluZWQgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhcmlhLXZhbHVlbWF4XCI6IGFsbG93T3ZlcmxhcCA/IG1heCA6IHZhbHVlc1tpbmRleCArIDFdIHx8IG1heCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYXJpYS12YWx1ZW1pblwiOiBhbGxvd092ZXJsYXAgPyBtaW4gOiB2YWx1ZXNbaW5kZXggLSAxXSB8fCBtaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFyaWEtdmFsdWVub3dcIjogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBfdGhpcy50aHVtYlJlZnNbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IGxhYmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogbGFiZWxsZWRCeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6IFwic2xpZGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbktleURvd246IGRpc2FibGVkID8gdXRpbHNfMS52b2lkRm4gOiBfdGhpcy5vbktleURvd24sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbktleVVwOiBkaXNhYmxlZCA/IHV0aWxzXzEudm9pZEZuIDogX3RoaXMub25LZXlVcCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLCB0cnVlKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSYW5nZS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGxhYmVsOiBcIkFjY2Vzc2liaWxpdHkgbGFiZWxcIixcbiAgICAgICAgbGFiZWxsZWRCeTogbnVsbCxcbiAgICAgICAgc3RlcDogMSxcbiAgICAgICAgZGlyZWN0aW9uOiB0eXBlc18xLkRpcmVjdGlvbi5SaWdodCxcbiAgICAgICAgcnRsOiBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBhbGxvd092ZXJsYXA6IGZhbHNlLFxuICAgICAgICBkcmFnZ2FibGVUcmFjazogZmFsc2UsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiAxMDAsXG4gICAgfTtcbiAgICByZXR1cm4gUmFuZ2U7XG59KFJlYWN0LkNvbXBvbmVudCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUmFuZ2U7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-range/lib/Range.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-range/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/react-range/lib/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.checkValuesAgainstBoundaries = exports.relativeValue = exports.useThumbOverlap = exports.Direction = exports.getTrackBackground = exports.Range = void 0;\nvar Range_1 = __importDefault(__webpack_require__(/*! ./Range */ \"(ssr)/./node_modules/react-range/lib/Range.js\"));\nexports.Range = Range_1.default;\nvar utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-range/lib/utils.js\");\nObject.defineProperty(exports, \"getTrackBackground\", ({ enumerable: true, get: function () { return utils_1.getTrackBackground; } }));\nObject.defineProperty(exports, \"useThumbOverlap\", ({ enumerable: true, get: function () { return utils_1.useThumbOverlap; } }));\nObject.defineProperty(exports, \"relativeValue\", ({ enumerable: true, get: function () { return utils_1.relativeValue; } }));\nObject.defineProperty(exports, \"checkValuesAgainstBoundaries\", ({ enumerable: true, get: function () { return utils_1.checkValuesAgainstBoundaries; } }));\nvar types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/react-range/lib/types.js\");\nObject.defineProperty(exports, \"Direction\", ({ enumerable: true, get: function () { return types_1.Direction; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0NBQW9DLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsaUJBQWlCLEdBQUcsMEJBQTBCLEdBQUcsYUFBYTtBQUN2Siw4QkFBOEIsbUJBQU8sQ0FBQyw4REFBUztBQUMvQyxhQUFhO0FBQ2IsY0FBYyxtQkFBTyxDQUFDLDhEQUFTO0FBQy9CLHNEQUFxRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNuSSxtREFBa0QsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDN0gsaURBQWdELEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3pILGdFQUErRCxFQUFFLHFDQUFxQyxnREFBZ0QsRUFBQztBQUN2SixjQUFjLG1CQUFPLENBQUMsOERBQVM7QUFDL0IsNkNBQTRDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDIiwic291cmNlcyI6WyIvaG9tZS9raXQvd29yay8xemFrYXpEdWJhaS9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGVja1ZhbHVlc0FnYWluc3RCb3VuZGFyaWVzID0gZXhwb3J0cy5yZWxhdGl2ZVZhbHVlID0gZXhwb3J0cy51c2VUaHVtYk92ZXJsYXAgPSBleHBvcnRzLkRpcmVjdGlvbiA9IGV4cG9ydHMuZ2V0VHJhY2tCYWNrZ3JvdW5kID0gZXhwb3J0cy5SYW5nZSA9IHZvaWQgMDtcbnZhciBSYW5nZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1JhbmdlXCIpKTtcbmV4cG9ydHMuUmFuZ2UgPSBSYW5nZV8xLmRlZmF1bHQ7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0VHJhY2tCYWNrZ3JvdW5kXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLmdldFRyYWNrQmFja2dyb3VuZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVzZVRodW1iT3ZlcmxhcFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS51c2VUaHVtYk92ZXJsYXA7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWxhdGl2ZVZhbHVlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLnJlbGF0aXZlVmFsdWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjaGVja1ZhbHVlc0FnYWluc3RCb3VuZGFyaWVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLmNoZWNrVmFsdWVzQWdhaW5zdEJvdW5kYXJpZXM7IH0gfSk7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlyZWN0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18xLkRpcmVjdGlvbjsgfSB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-range/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-range/lib/types.js":
/*!***********************************************!*\
  !*** ./node_modules/react-range/lib/types.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Direction = void 0;\nvar Direction;\n(function (Direction) {\n    Direction[\"Right\"] = \"to right\";\n    Direction[\"Left\"] = \"to left\";\n    Direction[\"Down\"] = \"to bottom\";\n    Direction[\"Up\"] = \"to top\";\n})(Direction || (exports.Direction = Direction = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQixpQkFBaUIsaUJBQWlCIiwic291cmNlcyI6WyIvaG9tZS9raXQvd29yay8xemFrYXpEdWJhaS9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL3R5cGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EaXJlY3Rpb24gPSB2b2lkIDA7XG52YXIgRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChEaXJlY3Rpb24pIHtcbiAgICBEaXJlY3Rpb25bXCJSaWdodFwiXSA9IFwidG8gcmlnaHRcIjtcbiAgICBEaXJlY3Rpb25bXCJMZWZ0XCJdID0gXCJ0byBsZWZ0XCI7XG4gICAgRGlyZWN0aW9uW1wiRG93blwiXSA9IFwidG8gYm90dG9tXCI7XG4gICAgRGlyZWN0aW9uW1wiVXBcIl0gPSBcInRvIHRvcFwiO1xufSkoRGlyZWN0aW9uIHx8IChleHBvcnRzLkRpcmVjdGlvbiA9IERpcmVjdGlvbiA9IHt9KSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-range/lib/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-range/lib/utils.js":
/*!***********************************************!*\
  !*** ./node_modules/react-range/lib/utils.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isIOS = exports.useThumbOverlap = exports.assertUnreachable = exports.voidFn = exports.getTrackBackground = exports.replaceAt = exports.schd = exports.translate = exports.getClosestThumbIndex = exports.translateThumbs = exports.getPaddingAndBorder = exports.getMargin = exports.checkInitialOverlap = exports.checkValuesAgainstBoundaries = exports.checkBoundaries = exports.isVertical = exports.relativeValue = exports.normalizeValue = exports.isStepDivisible = exports.isTouchEvent = exports.getStepDecimals = void 0;\nvar react_1 = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\nvar types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/react-range/lib/types.js\");\nvar getStepDecimals = function (step) {\n    var decimals = step.toString().split(\".\")[1];\n    return decimals ? decimals.length : 0;\n};\nexports.getStepDecimals = getStepDecimals;\nfunction isTouchEvent(event) {\n    return ((event.touches && event.touches.length) ||\n        (event.changedTouches && event.changedTouches.length));\n}\nexports.isTouchEvent = isTouchEvent;\nfunction isStepDivisible(min, max, step) {\n    var res = (max - min) / step;\n    var precision = 8;\n    var roundedRes = Number(res.toFixed(precision));\n    return parseInt(roundedRes.toString(), 10) === roundedRes;\n}\nexports.isStepDivisible = isStepDivisible;\nfunction normalizeValue(value, index, min, max, step, allowOverlap, values) {\n    var BIG_NUM = 10e10;\n    value = Math.round(value * BIG_NUM) / BIG_NUM;\n    if (!allowOverlap) {\n        var prev = values[index - 1];\n        var next = values[index + 1];\n        if (prev && prev > value)\n            return prev;\n        if (next && next < value)\n            return next;\n    }\n    if (value > max)\n        return max;\n    if (value < min)\n        return min;\n    // `remainder` is a difference between the given value and a full step value\n    // that is closest lower to the given value and is in the range between the min value\n    // and the given value\n    var remainder = Math.floor(value * BIG_NUM - min * BIG_NUM) % Math.floor(step * BIG_NUM);\n    var closestLowerNum = Math.floor(value * BIG_NUM - Math.abs(remainder));\n    var rounded = remainder === 0 ? value : closestLowerNum / BIG_NUM;\n    // Values with a remainder `< step/2` are rounded to the closest lower value\n    // while values with a remainder `= > step/2` are rounded to the closest bigger value\n    var res = Math.abs(remainder / BIG_NUM) < step / 2 ? rounded : rounded + step;\n    var decimalPlaces = (0, exports.getStepDecimals)(step);\n    return parseFloat(res.toFixed(decimalPlaces));\n}\nexports.normalizeValue = normalizeValue;\nfunction relativeValue(value, min, max) {\n    return (value - min) / (max - min);\n}\nexports.relativeValue = relativeValue;\nfunction isVertical(direction) {\n    return direction === types_1.Direction.Up || direction === types_1.Direction.Down;\n}\nexports.isVertical = isVertical;\nfunction checkBoundaries(value, min, max) {\n    if (min >= max) {\n        throw new RangeError(\"min (\".concat(min, \") is equal/bigger than max (\").concat(max, \")\"));\n    }\n    if (value < min) {\n        throw new RangeError(\"value (\".concat(value, \") is smaller than min (\").concat(min, \")\"));\n    }\n    if (value > max) {\n        throw new RangeError(\"value (\".concat(value, \") is bigger than max (\").concat(max, \")\"));\n    }\n}\nexports.checkBoundaries = checkBoundaries;\nfunction checkValuesAgainstBoundaries(value, min, max) {\n    if (value < min) {\n        // set selectedValue to min\n        return min;\n    }\n    if (value > max) {\n        // set selectedValue to max\n        return max;\n    }\n    else {\n        return value;\n    }\n}\nexports.checkValuesAgainstBoundaries = checkValuesAgainstBoundaries;\nfunction checkInitialOverlap(values) {\n    if (values.length < 2)\n        return;\n    if (!values.slice(1).every(function (item, i) { return values[i] <= item; })) {\n        throw new RangeError(\"values={[\".concat(values, \"]} needs to be sorted when allowOverlap={false}\"));\n    }\n}\nexports.checkInitialOverlap = checkInitialOverlap;\nfunction getMargin(element) {\n    var style = window.getComputedStyle(element);\n    return {\n        top: parseInt(style[\"margin-top\"], 10),\n        bottom: parseInt(style[\"margin-bottom\"], 10),\n        left: parseInt(style[\"margin-left\"], 10),\n        right: parseInt(style[\"margin-right\"], 10),\n    };\n}\nexports.getMargin = getMargin;\nfunction getPaddingAndBorder(element) {\n    var style = window.getComputedStyle(element);\n    return {\n        top: parseInt(style[\"padding-top\"], 10) +\n            parseInt(style[\"border-top-width\"], 10),\n        bottom: parseInt(style[\"padding-bottom\"], 10) +\n            parseInt(style[\"border-bottom-width\"], 10),\n        left: parseInt(style[\"padding-left\"], 10) +\n            parseInt(style[\"border-left-width\"], 10),\n        right: parseInt(style[\"padding-right\"], 10) +\n            parseInt(style[\"border-right-width\"], 10),\n    };\n}\nexports.getPaddingAndBorder = getPaddingAndBorder;\nfunction translateThumbs(elements, offsets, rtl) {\n    var inverter = rtl ? -1 : 1;\n    elements.forEach(function (element, index) {\n        return translate(element, inverter * offsets[index].x, offsets[index].y);\n    });\n}\nexports.translateThumbs = translateThumbs;\n/**\n * Util function for calculating the index of the thumb that is closes to a given position\n * @param thumbs - array of Thumb element to calculate the distance from\n * @param clientX - target x position (mouse/touch)\n * @param clientY - target y position (mouse/touch)\n * @param direction - the direction of the track\n */\nfunction getClosestThumbIndex(thumbs, clientX, clientY, direction) {\n    var thumbIndex = 0;\n    var minThumbDistance = getThumbDistance(thumbs[0], clientX, clientY, direction);\n    for (var i = 1; i < thumbs.length; i++) {\n        var thumbDistance = getThumbDistance(thumbs[i], clientX, clientY, direction);\n        if (thumbDistance < minThumbDistance) {\n            minThumbDistance = thumbDistance;\n            thumbIndex = i;\n        }\n    }\n    return thumbIndex;\n}\nexports.getClosestThumbIndex = getClosestThumbIndex;\nfunction translate(element, x, y) {\n    element.style.transform = \"translate(\".concat(x, \"px, \").concat(y, \"px)\");\n}\nexports.translate = translate;\n// adapted from https://github.com/alexreardon/raf-schd\nvar schd = function (fn) {\n    var lastArgs = [];\n    var frameId = null;\n    var wrapperFn = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        lastArgs = args;\n        if (frameId) {\n            return;\n        }\n        frameId = requestAnimationFrame(function () {\n            frameId = null;\n            fn.apply(void 0, lastArgs);\n        });\n    };\n    return wrapperFn;\n};\nexports.schd = schd;\nfunction replaceAt(values, index, value) {\n    var ret = values.slice(0);\n    ret[index] = value;\n    return ret;\n}\nexports.replaceAt = replaceAt;\nfunction getTrackBackground(_a) {\n    var values = _a.values, colors = _a.colors, min = _a.min, max = _a.max, _b = _a.direction, direction = _b === void 0 ? types_1.Direction.Right : _b, _c = _a.rtl, rtl = _c === void 0 ? false : _c;\n    if (rtl && direction === types_1.Direction.Right) {\n        direction = types_1.Direction.Left;\n    }\n    else if (rtl && types_1.Direction.Left) {\n        direction = types_1.Direction.Right;\n    }\n    // sort values ascending\n    var progress = values\n        .slice(0)\n        .sort(function (a, b) { return a - b; })\n        .map(function (value) { return ((value - min) / (max - min)) * 100; });\n    var middle = progress.reduce(function (acc, point, index) {\n        return \"\".concat(acc, \", \").concat(colors[index], \" \").concat(point, \"%, \").concat(colors[index + 1], \" \").concat(point, \"%\");\n    }, \"\");\n    return \"linear-gradient(\".concat(direction, \", \").concat(colors[0], \" 0%\").concat(middle, \", \").concat(colors[colors.length - 1], \" 100%)\");\n}\nexports.getTrackBackground = getTrackBackground;\nfunction voidFn() { }\nexports.voidFn = voidFn;\nfunction assertUnreachable(x) {\n    throw new Error(\"Didn't expect to get here\");\n}\nexports.assertUnreachable = assertUnreachable;\n/**\n * Util function for grabbing the true largest width of a thumb\n * including the label\n * @param thumbEl - Thumb element to grab the largest width from\n * @param value - Thumb value, not label value\n * @param separator - Label separator value\n */\nvar getThumbWidth = function (thumbEl, value, separator, decimalPlaces, valueToLabel) {\n    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }\n    var width = Math.ceil(__spreadArray([thumbEl], Array.from(thumbEl.children), true).reduce(function (width, el) {\n        var elWidth = Math.ceil(el.getBoundingClientRect().width);\n        /**\n         * If a label contains a merged label value, it won't return the true\n         * label width for that Thumb. Clone the label and change the value\n         * to that individual Thumb value in order to grab the true width.\n         */\n        if (el.innerText &&\n            el.innerText.includes(separator) &&\n            el.childElementCount === 0) {\n            var elClone = el.cloneNode(true);\n            elClone.innerHTML = valueToLabel(value.toFixed(decimalPlaces));\n            elClone.style.visibility = \"hidden\";\n            document.body.appendChild(elClone);\n            elWidth = Math.ceil(elClone.getBoundingClientRect().width);\n            document.body.removeChild(elClone);\n        }\n        return elWidth > width ? elWidth : width;\n    }, thumbEl.getBoundingClientRect().width));\n    return width;\n};\n/**\n * Bulk of logic for thumb overlaps\n * Consider a scenario with 5 thumbs;\n * Thumb 1 overlaps with thumb 0 and thumb 2\n * Thumb 2 overlaps with thumb 3\n * We need an array that contains [0, 1, 2, 3]\n * The function needs to return the directly overlapping thumbs\n * and all thumbs overlapping linked to those and so on\n * @param index - Thumb index calculating overlaps for\n * @param offsets - Current Array of Thumb offsets for Range\n * @param thumbs - Array of Thumb elements\n * @param values - Array of Thumb values\n * @param separator - String separator for merged label values\n * @returns overlaps - Array of all overlapping thumbs from the index\n */\nvar getOverlaps = function (index, offsets, thumbs, values, separator, decimalPlaces, valueToLabel) {\n    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }\n    var overlaps = [];\n    /**\n     * Recursive function for building the overlaps Array\n     * If an overlap is found, find the overlaps for that overlap\n     * @param thumbIndex current Thumb index to find overlaps from\n     */\n    var buildOverlaps = function (thumbIndex) {\n        var thumbXWidth = getThumbWidth(thumbs[thumbIndex], values[thumbIndex], separator, decimalPlaces, valueToLabel);\n        var thumbX = offsets[thumbIndex].x;\n        /**\n         * Iterate through the Thumb offsets, if there is a match\n         * add the thumbIndex and siblingIndex to the overlaps Array\n         *\n         * Then build overlaps from the overlapping siblingIndex\n         */\n        offsets.forEach(function (_a, siblingIndex) {\n            var siblingX = _a.x;\n            var siblingWidth = getThumbWidth(thumbs[siblingIndex], values[siblingIndex], separator, decimalPlaces, valueToLabel);\n            if (thumbIndex !== siblingIndex &&\n                ((thumbX >= siblingX && thumbX <= siblingX + siblingWidth) ||\n                    (thumbX + thumbXWidth >= siblingX &&\n                        thumbX + thumbXWidth <= siblingX + siblingWidth))) {\n                if (!overlaps.includes(siblingIndex)) {\n                    overlaps.push(thumbIndex);\n                    overlaps.push(siblingIndex);\n                    overlaps = __spreadArray(__spreadArray([], overlaps, true), [thumbIndex, siblingIndex], false);\n                    buildOverlaps(siblingIndex);\n                }\n            }\n        });\n    };\n    buildOverlaps(index);\n    // Sort and remove duplicates from the built overlaps\n    return Array.from(new Set(overlaps.sort()));\n};\n/**\n * A custom React Hook for calculating whether a thumb overlaps\n * another and whether labels could/should merge.\n * @param rangeRef - React ref value of Range component\n * @param values - current Range values Array\n * @param index - thumb index\n * @param step - step value, used to calculate the number of decimal places\n * @param separator - string to separate thumb values\n * @returns label value + styling for thumb label\n */\nvar useThumbOverlap = function (rangeRef, values, index, step, separator, valueToLabel) {\n    if (step === void 0) { step = 0.1; }\n    if (separator === void 0) { separator = \" - \"; }\n    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }\n    var decimalPlaces = (0, exports.getStepDecimals)(step);\n    // Create initial label style and value. Label value defaults to thumb value\n    var _a = (0, react_1.useState)({}), labelStyle = _a[0], setLabelStyle = _a[1];\n    var _b = (0, react_1.useState)(valueToLabel(values[index].toFixed(decimalPlaces))), labelValue = _b[0], setLabelValue = _b[1];\n    // When the rangeRef or values change, update the Thumb label values and styling\n    (0, react_1.useEffect)(function () {\n        if (rangeRef) {\n            var thumbs = rangeRef.getThumbs();\n            if (thumbs.length < 1)\n                return;\n            var newStyle = {};\n            var offsets_1 = rangeRef.getOffsets();\n            /**\n             * Get any overlaps for the given Thumb index. This must return all linked\n             * Thumbs. So if there are 4 Thumbs and Thumbs 2, 3 and 4 overlap. If we are\n             * getting the overlaps for Thumb 1 and it overlaps only Thumb 2, we must get\n             * 2, 3 and 4 also.\n             */\n            var overlaps = getOverlaps(index, offsets_1, thumbs, values, separator, decimalPlaces, valueToLabel);\n            // Set a default label value of the Thumb value\n            var labelValue_1 = valueToLabel(values[index].toFixed(decimalPlaces));\n            /**\n             * If there are overlaps for the Thumb, we need to calculate the correct\n             * Label value along with the relevant styling. We only want to show a Label\n             * for the left most Thumb in an overlapping set.\n             * All other Thumbs will be set to display: none.\n             */\n            if (overlaps.length) {\n                /**\n                 * Get an Array of the offsets for the overlapping Thumbs\n                 * This is so we can determine if the Thumb we are looking at\n                 * is the left most thumb in an overlapping set\n                 */\n                var offsetsX = overlaps.reduce(function (a, c, i, s) {\n                    return a.length ? __spreadArray(__spreadArray([], a, true), [offsets_1[s[i]].x], false) : [offsets_1[s[i]].x];\n                }, []);\n                /**\n                 * If our Thumb is the left most Thumb, we can build a Label value\n                 * and set the style for that Label\n                 */\n                if (Math.min.apply(Math, offsetsX) === offsets_1[index].x) {\n                    /**\n                     * First calculate the Label value. To do this,\n                     * grab all the values for the Thumbs in our overlaps.\n                     * Then convert that to a Set and sort it whilst removing duplicates.\n                     */\n                    var labelValues_1 = [];\n                    overlaps.forEach(function (thumb) {\n                        labelValues_1.push(values[thumb].toFixed(decimalPlaces));\n                    });\n                    /**\n                     *  Update the labelValue with the resulting Array\n                     *  joined by our defined separator\n                     */\n                    labelValue_1 = Array.from(new Set(labelValues_1.sort(function (a, b) { return parseFloat(a) - parseFloat(b); })))\n                        .map(valueToLabel)\n                        .join(separator);\n                    /**\n                     * Lastly, build the label styling. The label styling will\n                     * position the label and apply a transform so that it's centered.\n                     * We want the center point between the left edge of the left most Thumb\n                     * and the right edge of the right most Thumb.\n                     */\n                    var first = Math.min.apply(Math, offsetsX);\n                    var last = Math.max.apply(Math, offsetsX);\n                    var lastWidth = thumbs[overlaps[offsetsX.indexOf(last)]].getBoundingClientRect()\n                        .width;\n                    newStyle.left = \"\".concat(Math.abs(first - (last + lastWidth)) / 2, \"px\");\n                    newStyle.transform = \"translate(-50%, 0)\";\n                }\n                else {\n                    // If the Thumb isn't the left most Thumb, hide the Label!\n                    newStyle.visibility = \"hidden\";\n                }\n            }\n            // Update the label value and style\n            setLabelValue(labelValue_1);\n            setLabelStyle(newStyle);\n        }\n    }, [rangeRef, values]);\n    return [labelValue, labelStyle];\n};\nexports.useThumbOverlap = useThumbOverlap;\n/**\n * Util function for calculating the distance of the center of a thumb\n * form a given mouse/touch target's position\n * @param thumbEl - Thumb element to calculate the distance from\n * @param clientX - target x position (mouse/touch)\n * @param clientY - target y position (mouse/touch)\n * @param direction - the direction of the track\n */\nfunction getThumbDistance(thumbEl, clientX, clientY, direction) {\n    var _a = thumbEl.getBoundingClientRect(), left = _a.left, top = _a.top, width = _a.width, height = _a.height;\n    return isVertical(direction)\n        ? Math.abs(clientY - (top + height / 2))\n        : Math.abs(clientX - (left + width / 2));\n}\nvar isIOS = function () {\n    var _a;\n    // @ts-ignore\n    var platform = ((_a = navigator.userAgentData) === null || _a === void 0 ? void 0 : _a.platform) || navigator.platform;\n    return ([\n        \"iPad Simulator\",\n        \"iPhone Simulator\",\n        \"iPod Simulator\",\n        \"iPad\",\n        \"iPhone\",\n        \"iPod\",\n    ].includes(platform) ||\n        // iPad on iOS 13 detection\n        (navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document));\n};\nexports.isIOS = isIOS;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcsdUJBQXVCLEdBQUcseUJBQXlCLEdBQUcsY0FBYyxHQUFHLDBCQUEwQixHQUFHLGlCQUFpQixHQUFHLFlBQVksR0FBRyxpQkFBaUIsR0FBRyw0QkFBNEIsR0FBRyx1QkFBdUIsR0FBRywyQkFBMkIsR0FBRyxpQkFBaUIsR0FBRywyQkFBMkIsR0FBRyxvQ0FBb0MsR0FBRyx1QkFBdUIsR0FBRyxrQkFBa0IsR0FBRyxxQkFBcUIsR0FBRyxzQkFBc0IsR0FBRyx1QkFBdUIsR0FBRyxvQkFBb0IsR0FBRyx1QkFBdUI7QUFDbmdCLGNBQWMsbUJBQU8sQ0FBQyxpR0FBTztBQUM3QixjQUFjLG1CQUFPLENBQUMsOERBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0w7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSIsInNvdXJjZXMiOlsiL2hvbWUva2l0L3dvcmsvMXpha2F6RHViYWkvbm9kZV9tb2R1bGVzL3JlYWN0LXJhbmdlL2xpYi91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNJT1MgPSBleHBvcnRzLnVzZVRodW1iT3ZlcmxhcCA9IGV4cG9ydHMuYXNzZXJ0VW5yZWFjaGFibGUgPSBleHBvcnRzLnZvaWRGbiA9IGV4cG9ydHMuZ2V0VHJhY2tCYWNrZ3JvdW5kID0gZXhwb3J0cy5yZXBsYWNlQXQgPSBleHBvcnRzLnNjaGQgPSBleHBvcnRzLnRyYW5zbGF0ZSA9IGV4cG9ydHMuZ2V0Q2xvc2VzdFRodW1iSW5kZXggPSBleHBvcnRzLnRyYW5zbGF0ZVRodW1icyA9IGV4cG9ydHMuZ2V0UGFkZGluZ0FuZEJvcmRlciA9IGV4cG9ydHMuZ2V0TWFyZ2luID0gZXhwb3J0cy5jaGVja0luaXRpYWxPdmVybGFwID0gZXhwb3J0cy5jaGVja1ZhbHVlc0FnYWluc3RCb3VuZGFyaWVzID0gZXhwb3J0cy5jaGVja0JvdW5kYXJpZXMgPSBleHBvcnRzLmlzVmVydGljYWwgPSBleHBvcnRzLnJlbGF0aXZlVmFsdWUgPSBleHBvcnRzLm5vcm1hbGl6ZVZhbHVlID0gZXhwb3J0cy5pc1N0ZXBEaXZpc2libGUgPSBleHBvcnRzLmlzVG91Y2hFdmVudCA9IGV4cG9ydHMuZ2V0U3RlcERlY2ltYWxzID0gdm9pZCAwO1xudmFyIHJlYWN0XzEgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xudmFyIGdldFN0ZXBEZWNpbWFscyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgdmFyIGRlY2ltYWxzID0gc3RlcC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXTtcbiAgICByZXR1cm4gZGVjaW1hbHMgPyBkZWNpbWFscy5sZW5ndGggOiAwO1xufTtcbmV4cG9ydHMuZ2V0U3RlcERlY2ltYWxzID0gZ2V0U3RlcERlY2ltYWxzO1xuZnVuY3Rpb24gaXNUb3VjaEV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuICgoZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCkgfHxcbiAgICAgICAgKGV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCkpO1xufVxuZXhwb3J0cy5pc1RvdWNoRXZlbnQgPSBpc1RvdWNoRXZlbnQ7XG5mdW5jdGlvbiBpc1N0ZXBEaXZpc2libGUobWluLCBtYXgsIHN0ZXApIHtcbiAgICB2YXIgcmVzID0gKG1heCAtIG1pbikgLyBzdGVwO1xuICAgIHZhciBwcmVjaXNpb24gPSA4O1xuICAgIHZhciByb3VuZGVkUmVzID0gTnVtYmVyKHJlcy50b0ZpeGVkKHByZWNpc2lvbikpO1xuICAgIHJldHVybiBwYXJzZUludChyb3VuZGVkUmVzLnRvU3RyaW5nKCksIDEwKSA9PT0gcm91bmRlZFJlcztcbn1cbmV4cG9ydHMuaXNTdGVwRGl2aXNpYmxlID0gaXNTdGVwRGl2aXNpYmxlO1xuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUsIGluZGV4LCBtaW4sIG1heCwgc3RlcCwgYWxsb3dPdmVybGFwLCB2YWx1ZXMpIHtcbiAgICB2YXIgQklHX05VTSA9IDEwZTEwO1xuICAgIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIEJJR19OVU0pIC8gQklHX05VTTtcbiAgICBpZiAoIWFsbG93T3ZlcmxhcCkge1xuICAgICAgICB2YXIgcHJldiA9IHZhbHVlc1tpbmRleCAtIDFdO1xuICAgICAgICB2YXIgbmV4dCA9IHZhbHVlc1tpbmRleCArIDFdO1xuICAgICAgICBpZiAocHJldiAmJiBwcmV2ID4gdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgaWYgKG5leHQgJiYgbmV4dCA8IHZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+IG1heClcbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICBpZiAodmFsdWUgPCBtaW4pXG4gICAgICAgIHJldHVybiBtaW47XG4gICAgLy8gYHJlbWFpbmRlcmAgaXMgYSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGdpdmVuIHZhbHVlIGFuZCBhIGZ1bGwgc3RlcCB2YWx1ZVxuICAgIC8vIHRoYXQgaXMgY2xvc2VzdCBsb3dlciB0byB0aGUgZ2l2ZW4gdmFsdWUgYW5kIGlzIGluIHRoZSByYW5nZSBiZXR3ZWVuIHRoZSBtaW4gdmFsdWVcbiAgICAvLyBhbmQgdGhlIGdpdmVuIHZhbHVlXG4gICAgdmFyIHJlbWFpbmRlciA9IE1hdGguZmxvb3IodmFsdWUgKiBCSUdfTlVNIC0gbWluICogQklHX05VTSkgJSBNYXRoLmZsb29yKHN0ZXAgKiBCSUdfTlVNKTtcbiAgICB2YXIgY2xvc2VzdExvd2VyTnVtID0gTWF0aC5mbG9vcih2YWx1ZSAqIEJJR19OVU0gLSBNYXRoLmFicyhyZW1haW5kZXIpKTtcbiAgICB2YXIgcm91bmRlZCA9IHJlbWFpbmRlciA9PT0gMCA/IHZhbHVlIDogY2xvc2VzdExvd2VyTnVtIC8gQklHX05VTTtcbiAgICAvLyBWYWx1ZXMgd2l0aCBhIHJlbWFpbmRlciBgPCBzdGVwLzJgIGFyZSByb3VuZGVkIHRvIHRoZSBjbG9zZXN0IGxvd2VyIHZhbHVlXG4gICAgLy8gd2hpbGUgdmFsdWVzIHdpdGggYSByZW1haW5kZXIgYD0gPiBzdGVwLzJgIGFyZSByb3VuZGVkIHRvIHRoZSBjbG9zZXN0IGJpZ2dlciB2YWx1ZVxuICAgIHZhciByZXMgPSBNYXRoLmFicyhyZW1haW5kZXIgLyBCSUdfTlVNKSA8IHN0ZXAgLyAyID8gcm91bmRlZCA6IHJvdW5kZWQgKyBzdGVwO1xuICAgIHZhciBkZWNpbWFsUGxhY2VzID0gKDAsIGV4cG9ydHMuZ2V0U3RlcERlY2ltYWxzKShzdGVwKTtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChyZXMudG9GaXhlZChkZWNpbWFsUGxhY2VzKSk7XG59XG5leHBvcnRzLm5vcm1hbGl6ZVZhbHVlID0gbm9ybWFsaXplVmFsdWU7XG5mdW5jdGlvbiByZWxhdGl2ZVZhbHVlKHZhbHVlLCBtaW4sIG1heCkge1xuICAgIHJldHVybiAodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbik7XG59XG5leHBvcnRzLnJlbGF0aXZlVmFsdWUgPSByZWxhdGl2ZVZhbHVlO1xuZnVuY3Rpb24gaXNWZXJ0aWNhbChkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gZGlyZWN0aW9uID09PSB0eXBlc18xLkRpcmVjdGlvbi5VcCB8fCBkaXJlY3Rpb24gPT09IHR5cGVzXzEuRGlyZWN0aW9uLkRvd247XG59XG5leHBvcnRzLmlzVmVydGljYWwgPSBpc1ZlcnRpY2FsO1xuZnVuY3Rpb24gY2hlY2tCb3VuZGFyaWVzKHZhbHVlLCBtaW4sIG1heCkge1xuICAgIGlmIChtaW4gPj0gbWF4KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwibWluIChcIi5jb25jYXQobWluLCBcIikgaXMgZXF1YWwvYmlnZ2VyIHRoYW4gbWF4IChcIikuY29uY2F0KG1heCwgXCIpXCIpKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwidmFsdWUgKFwiLmNvbmNhdCh2YWx1ZSwgXCIpIGlzIHNtYWxsZXIgdGhhbiBtaW4gKFwiKS5jb25jYXQobWluLCBcIilcIikpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ2YWx1ZSAoXCIuY29uY2F0KHZhbHVlLCBcIikgaXMgYmlnZ2VyIHRoYW4gbWF4IChcIikuY29uY2F0KG1heCwgXCIpXCIpKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrQm91bmRhcmllcyA9IGNoZWNrQm91bmRhcmllcztcbmZ1bmN0aW9uIGNoZWNrVmFsdWVzQWdhaW5zdEJvdW5kYXJpZXModmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgIC8vIHNldCBzZWxlY3RlZFZhbHVlIHRvIG1pblxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgLy8gc2V0IHNlbGVjdGVkVmFsdWUgdG8gbWF4XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja1ZhbHVlc0FnYWluc3RCb3VuZGFyaWVzID0gY2hlY2tWYWx1ZXNBZ2FpbnN0Qm91bmRhcmllcztcbmZ1bmN0aW9uIGNoZWNrSW5pdGlhbE92ZXJsYXAodmFsdWVzKSB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPCAyKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCF2YWx1ZXMuc2xpY2UoMSkuZXZlcnkoZnVuY3Rpb24gKGl0ZW0sIGkpIHsgcmV0dXJuIHZhbHVlc1tpXSA8PSBpdGVtOyB9KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInZhbHVlcz17W1wiLmNvbmNhdCh2YWx1ZXMsIFwiXX0gbmVlZHMgdG8gYmUgc29ydGVkIHdoZW4gYWxsb3dPdmVybGFwPXtmYWxzZX1cIikpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tJbml0aWFsT3ZlcmxhcCA9IGNoZWNrSW5pdGlhbE92ZXJsYXA7XG5mdW5jdGlvbiBnZXRNYXJnaW4oZWxlbWVudCkge1xuICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogcGFyc2VJbnQoc3R5bGVbXCJtYXJnaW4tdG9wXCJdLCAxMCksXG4gICAgICAgIGJvdHRvbTogcGFyc2VJbnQoc3R5bGVbXCJtYXJnaW4tYm90dG9tXCJdLCAxMCksXG4gICAgICAgIGxlZnQ6IHBhcnNlSW50KHN0eWxlW1wibWFyZ2luLWxlZnRcIl0sIDEwKSxcbiAgICAgICAgcmlnaHQ6IHBhcnNlSW50KHN0eWxlW1wibWFyZ2luLXJpZ2h0XCJdLCAxMCksXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0TWFyZ2luID0gZ2V0TWFyZ2luO1xuZnVuY3Rpb24gZ2V0UGFkZGluZ0FuZEJvcmRlcihlbGVtZW50KSB7XG4gICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBwYXJzZUludChzdHlsZVtcInBhZGRpbmctdG9wXCJdLCAxMCkgK1xuICAgICAgICAgICAgcGFyc2VJbnQoc3R5bGVbXCJib3JkZXItdG9wLXdpZHRoXCJdLCAxMCksXG4gICAgICAgIGJvdHRvbTogcGFyc2VJbnQoc3R5bGVbXCJwYWRkaW5nLWJvdHRvbVwiXSwgMTApICtcbiAgICAgICAgICAgIHBhcnNlSW50KHN0eWxlW1wiYm9yZGVyLWJvdHRvbS13aWR0aFwiXSwgMTApLFxuICAgICAgICBsZWZ0OiBwYXJzZUludChzdHlsZVtcInBhZGRpbmctbGVmdFwiXSwgMTApICtcbiAgICAgICAgICAgIHBhcnNlSW50KHN0eWxlW1wiYm9yZGVyLWxlZnQtd2lkdGhcIl0sIDEwKSxcbiAgICAgICAgcmlnaHQ6IHBhcnNlSW50KHN0eWxlW1wicGFkZGluZy1yaWdodFwiXSwgMTApICtcbiAgICAgICAgICAgIHBhcnNlSW50KHN0eWxlW1wiYm9yZGVyLXJpZ2h0LXdpZHRoXCJdLCAxMCksXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0UGFkZGluZ0FuZEJvcmRlciA9IGdldFBhZGRpbmdBbmRCb3JkZXI7XG5mdW5jdGlvbiB0cmFuc2xhdGVUaHVtYnMoZWxlbWVudHMsIG9mZnNldHMsIHJ0bCkge1xuICAgIHZhciBpbnZlcnRlciA9IHJ0bCA/IC0xIDogMTtcbiAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gdHJhbnNsYXRlKGVsZW1lbnQsIGludmVydGVyICogb2Zmc2V0c1tpbmRleF0ueCwgb2Zmc2V0c1tpbmRleF0ueSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnRyYW5zbGF0ZVRodW1icyA9IHRyYW5zbGF0ZVRodW1icztcbi8qKlxuICogVXRpbCBmdW5jdGlvbiBmb3IgY2FsY3VsYXRpbmcgdGhlIGluZGV4IG9mIHRoZSB0aHVtYiB0aGF0IGlzIGNsb3NlcyB0byBhIGdpdmVuIHBvc2l0aW9uXG4gKiBAcGFyYW0gdGh1bWJzIC0gYXJyYXkgb2YgVGh1bWIgZWxlbWVudCB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGZyb21cbiAqIEBwYXJhbSBjbGllbnRYIC0gdGFyZ2V0IHggcG9zaXRpb24gKG1vdXNlL3RvdWNoKVxuICogQHBhcmFtIGNsaWVudFkgLSB0YXJnZXQgeSBwb3NpdGlvbiAobW91c2UvdG91Y2gpXG4gKiBAcGFyYW0gZGlyZWN0aW9uIC0gdGhlIGRpcmVjdGlvbiBvZiB0aGUgdHJhY2tcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdFRodW1iSW5kZXgodGh1bWJzLCBjbGllbnRYLCBjbGllbnRZLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgdGh1bWJJbmRleCA9IDA7XG4gICAgdmFyIG1pblRodW1iRGlzdGFuY2UgPSBnZXRUaHVtYkRpc3RhbmNlKHRodW1ic1swXSwgY2xpZW50WCwgY2xpZW50WSwgZGlyZWN0aW9uKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRodW1icy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdGh1bWJEaXN0YW5jZSA9IGdldFRodW1iRGlzdGFuY2UodGh1bWJzW2ldLCBjbGllbnRYLCBjbGllbnRZLCBkaXJlY3Rpb24pO1xuICAgICAgICBpZiAodGh1bWJEaXN0YW5jZSA8IG1pblRodW1iRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIG1pblRodW1iRGlzdGFuY2UgPSB0aHVtYkRpc3RhbmNlO1xuICAgICAgICAgICAgdGh1bWJJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRodW1iSW5kZXg7XG59XG5leHBvcnRzLmdldENsb3Nlc3RUaHVtYkluZGV4ID0gZ2V0Q2xvc2VzdFRodW1iSW5kZXg7XG5mdW5jdGlvbiB0cmFuc2xhdGUoZWxlbWVudCwgeCwgeSkge1xuICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHgsIFwicHgsIFwiKS5jb25jYXQoeSwgXCJweClcIik7XG59XG5leHBvcnRzLnRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYWxleHJlYXJkb24vcmFmLXNjaGRcbnZhciBzY2hkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGxhc3RBcmdzID0gW107XG4gICAgdmFyIGZyYW1lSWQgPSBudWxsO1xuICAgIHZhciB3cmFwcGVyRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEFyZ3MgPSBhcmdzO1xuICAgICAgICBpZiAoZnJhbWVJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnJhbWVJZCA9IG51bGw7XG4gICAgICAgICAgICBmbi5hcHBseSh2b2lkIDAsIGxhc3RBcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gd3JhcHBlckZuO1xufTtcbmV4cG9ydHMuc2NoZCA9IHNjaGQ7XG5mdW5jdGlvbiByZXBsYWNlQXQodmFsdWVzLCBpbmRleCwgdmFsdWUpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWVzLnNsaWNlKDApO1xuICAgIHJldFtpbmRleF0gPSB2YWx1ZTtcbiAgICByZXR1cm4gcmV0O1xufVxuZXhwb3J0cy5yZXBsYWNlQXQgPSByZXBsYWNlQXQ7XG5mdW5jdGlvbiBnZXRUcmFja0JhY2tncm91bmQoX2EpIHtcbiAgICB2YXIgdmFsdWVzID0gX2EudmFsdWVzLCBjb2xvcnMgPSBfYS5jb2xvcnMsIG1pbiA9IF9hLm1pbiwgbWF4ID0gX2EubWF4LCBfYiA9IF9hLmRpcmVjdGlvbiwgZGlyZWN0aW9uID0gX2IgPT09IHZvaWQgMCA/IHR5cGVzXzEuRGlyZWN0aW9uLlJpZ2h0IDogX2IsIF9jID0gX2EucnRsLCBydGwgPSBfYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYztcbiAgICBpZiAocnRsICYmIGRpcmVjdGlvbiA9PT0gdHlwZXNfMS5EaXJlY3Rpb24uUmlnaHQpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gdHlwZXNfMS5EaXJlY3Rpb24uTGVmdDtcbiAgICB9XG4gICAgZWxzZSBpZiAocnRsICYmIHR5cGVzXzEuRGlyZWN0aW9uLkxlZnQpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gdHlwZXNfMS5EaXJlY3Rpb24uUmlnaHQ7XG4gICAgfVxuICAgIC8vIHNvcnQgdmFsdWVzIGFzY2VuZGluZ1xuICAgIHZhciBwcm9ncmVzcyA9IHZhbHVlc1xuICAgICAgICAuc2xpY2UoMClcbiAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gKCh2YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKSkgKiAxMDA7IH0pO1xuICAgIHZhciBtaWRkbGUgPSBwcm9ncmVzcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcG9pbnQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChhY2MsIFwiLCBcIikuY29uY2F0KGNvbG9yc1tpbmRleF0sIFwiIFwiKS5jb25jYXQocG9pbnQsIFwiJSwgXCIpLmNvbmNhdChjb2xvcnNbaW5kZXggKyAxXSwgXCIgXCIpLmNvbmNhdChwb2ludCwgXCIlXCIpO1xuICAgIH0sIFwiXCIpO1xuICAgIHJldHVybiBcImxpbmVhci1ncmFkaWVudChcIi5jb25jYXQoZGlyZWN0aW9uLCBcIiwgXCIpLmNvbmNhdChjb2xvcnNbMF0sIFwiIDAlXCIpLmNvbmNhdChtaWRkbGUsIFwiLCBcIikuY29uY2F0KGNvbG9yc1tjb2xvcnMubGVuZ3RoIC0gMV0sIFwiIDEwMCUpXCIpO1xufVxuZXhwb3J0cy5nZXRUcmFja0JhY2tncm91bmQgPSBnZXRUcmFja0JhY2tncm91bmQ7XG5mdW5jdGlvbiB2b2lkRm4oKSB7IH1cbmV4cG9ydHMudm9pZEZuID0gdm9pZEZuO1xuZnVuY3Rpb24gYXNzZXJ0VW5yZWFjaGFibGUoeCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkRpZG4ndCBleHBlY3QgdG8gZ2V0IGhlcmVcIik7XG59XG5leHBvcnRzLmFzc2VydFVucmVhY2hhYmxlID0gYXNzZXJ0VW5yZWFjaGFibGU7XG4vKipcbiAqIFV0aWwgZnVuY3Rpb24gZm9yIGdyYWJiaW5nIHRoZSB0cnVlIGxhcmdlc3Qgd2lkdGggb2YgYSB0aHVtYlxuICogaW5jbHVkaW5nIHRoZSBsYWJlbFxuICogQHBhcmFtIHRodW1iRWwgLSBUaHVtYiBlbGVtZW50IHRvIGdyYWIgdGhlIGxhcmdlc3Qgd2lkdGggZnJvbVxuICogQHBhcmFtIHZhbHVlIC0gVGh1bWIgdmFsdWUsIG5vdCBsYWJlbCB2YWx1ZVxuICogQHBhcmFtIHNlcGFyYXRvciAtIExhYmVsIHNlcGFyYXRvciB2YWx1ZVxuICovXG52YXIgZ2V0VGh1bWJXaWR0aCA9IGZ1bmN0aW9uICh0aHVtYkVsLCB2YWx1ZSwgc2VwYXJhdG9yLCBkZWNpbWFsUGxhY2VzLCB2YWx1ZVRvTGFiZWwpIHtcbiAgICBpZiAodmFsdWVUb0xhYmVsID09PSB2b2lkIDApIHsgdmFsdWVUb0xhYmVsID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTsgfVxuICAgIHZhciB3aWR0aCA9IE1hdGguY2VpbChfX3NwcmVhZEFycmF5KFt0aHVtYkVsXSwgQXJyYXkuZnJvbSh0aHVtYkVsLmNoaWxkcmVuKSwgdHJ1ZSkucmVkdWNlKGZ1bmN0aW9uICh3aWR0aCwgZWwpIHtcbiAgICAgICAgdmFyIGVsV2lkdGggPSBNYXRoLmNlaWwoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYSBsYWJlbCBjb250YWlucyBhIG1lcmdlZCBsYWJlbCB2YWx1ZSwgaXQgd29uJ3QgcmV0dXJuIHRoZSB0cnVlXG4gICAgICAgICAqIGxhYmVsIHdpZHRoIGZvciB0aGF0IFRodW1iLiBDbG9uZSB0aGUgbGFiZWwgYW5kIGNoYW5nZSB0aGUgdmFsdWVcbiAgICAgICAgICogdG8gdGhhdCBpbmRpdmlkdWFsIFRodW1iIHZhbHVlIGluIG9yZGVyIHRvIGdyYWIgdGhlIHRydWUgd2lkdGguXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZWwuaW5uZXJUZXh0ICYmXG4gICAgICAgICAgICBlbC5pbm5lclRleHQuaW5jbHVkZXMoc2VwYXJhdG9yKSAmJlxuICAgICAgICAgICAgZWwuY2hpbGRFbGVtZW50Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHZhciBlbENsb25lID0gZWwuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgZWxDbG9uZS5pbm5lckhUTUwgPSB2YWx1ZVRvTGFiZWwodmFsdWUudG9GaXhlZChkZWNpbWFsUGxhY2VzKSk7XG4gICAgICAgICAgICBlbENsb25lLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbENsb25lKTtcbiAgICAgICAgICAgIGVsV2lkdGggPSBNYXRoLmNlaWwoZWxDbG9uZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsQ2xvbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbFdpZHRoID4gd2lkdGggPyBlbFdpZHRoIDogd2lkdGg7XG4gICAgfSwgdGh1bWJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCkpO1xuICAgIHJldHVybiB3aWR0aDtcbn07XG4vKipcbiAqIEJ1bGsgb2YgbG9naWMgZm9yIHRodW1iIG92ZXJsYXBzXG4gKiBDb25zaWRlciBhIHNjZW5hcmlvIHdpdGggNSB0aHVtYnM7XG4gKiBUaHVtYiAxIG92ZXJsYXBzIHdpdGggdGh1bWIgMCBhbmQgdGh1bWIgMlxuICogVGh1bWIgMiBvdmVybGFwcyB3aXRoIHRodW1iIDNcbiAqIFdlIG5lZWQgYW4gYXJyYXkgdGhhdCBjb250YWlucyBbMCwgMSwgMiwgM11cbiAqIFRoZSBmdW5jdGlvbiBuZWVkcyB0byByZXR1cm4gdGhlIGRpcmVjdGx5IG92ZXJsYXBwaW5nIHRodW1ic1xuICogYW5kIGFsbCB0aHVtYnMgb3ZlcmxhcHBpbmcgbGlua2VkIHRvIHRob3NlIGFuZCBzbyBvblxuICogQHBhcmFtIGluZGV4IC0gVGh1bWIgaW5kZXggY2FsY3VsYXRpbmcgb3ZlcmxhcHMgZm9yXG4gKiBAcGFyYW0gb2Zmc2V0cyAtIEN1cnJlbnQgQXJyYXkgb2YgVGh1bWIgb2Zmc2V0cyBmb3IgUmFuZ2VcbiAqIEBwYXJhbSB0aHVtYnMgLSBBcnJheSBvZiBUaHVtYiBlbGVtZW50c1xuICogQHBhcmFtIHZhbHVlcyAtIEFycmF5IG9mIFRodW1iIHZhbHVlc1xuICogQHBhcmFtIHNlcGFyYXRvciAtIFN0cmluZyBzZXBhcmF0b3IgZm9yIG1lcmdlZCBsYWJlbCB2YWx1ZXNcbiAqIEByZXR1cm5zIG92ZXJsYXBzIC0gQXJyYXkgb2YgYWxsIG92ZXJsYXBwaW5nIHRodW1icyBmcm9tIHRoZSBpbmRleFxuICovXG52YXIgZ2V0T3ZlcmxhcHMgPSBmdW5jdGlvbiAoaW5kZXgsIG9mZnNldHMsIHRodW1icywgdmFsdWVzLCBzZXBhcmF0b3IsIGRlY2ltYWxQbGFjZXMsIHZhbHVlVG9MYWJlbCkge1xuICAgIGlmICh2YWx1ZVRvTGFiZWwgPT09IHZvaWQgMCkgeyB2YWx1ZVRvTGFiZWwgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9OyB9XG4gICAgdmFyIG92ZXJsYXBzID0gW107XG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlIGZ1bmN0aW9uIGZvciBidWlsZGluZyB0aGUgb3ZlcmxhcHMgQXJyYXlcbiAgICAgKiBJZiBhbiBvdmVybGFwIGlzIGZvdW5kLCBmaW5kIHRoZSBvdmVybGFwcyBmb3IgdGhhdCBvdmVybGFwXG4gICAgICogQHBhcmFtIHRodW1iSW5kZXggY3VycmVudCBUaHVtYiBpbmRleCB0byBmaW5kIG92ZXJsYXBzIGZyb21cbiAgICAgKi9cbiAgICB2YXIgYnVpbGRPdmVybGFwcyA9IGZ1bmN0aW9uICh0aHVtYkluZGV4KSB7XG4gICAgICAgIHZhciB0aHVtYlhXaWR0aCA9IGdldFRodW1iV2lkdGgodGh1bWJzW3RodW1iSW5kZXhdLCB2YWx1ZXNbdGh1bWJJbmRleF0sIHNlcGFyYXRvciwgZGVjaW1hbFBsYWNlcywgdmFsdWVUb0xhYmVsKTtcbiAgICAgICAgdmFyIHRodW1iWCA9IG9mZnNldHNbdGh1bWJJbmRleF0ueDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGUgdGhyb3VnaCB0aGUgVGh1bWIgb2Zmc2V0cywgaWYgdGhlcmUgaXMgYSBtYXRjaFxuICAgICAgICAgKiBhZGQgdGhlIHRodW1iSW5kZXggYW5kIHNpYmxpbmdJbmRleCB0byB0aGUgb3ZlcmxhcHMgQXJyYXlcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlbiBidWlsZCBvdmVybGFwcyBmcm9tIHRoZSBvdmVybGFwcGluZyBzaWJsaW5nSW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIG9mZnNldHMuZm9yRWFjaChmdW5jdGlvbiAoX2EsIHNpYmxpbmdJbmRleCkge1xuICAgICAgICAgICAgdmFyIHNpYmxpbmdYID0gX2EueDtcbiAgICAgICAgICAgIHZhciBzaWJsaW5nV2lkdGggPSBnZXRUaHVtYldpZHRoKHRodW1ic1tzaWJsaW5nSW5kZXhdLCB2YWx1ZXNbc2libGluZ0luZGV4XSwgc2VwYXJhdG9yLCBkZWNpbWFsUGxhY2VzLCB2YWx1ZVRvTGFiZWwpO1xuICAgICAgICAgICAgaWYgKHRodW1iSW5kZXggIT09IHNpYmxpbmdJbmRleCAmJlxuICAgICAgICAgICAgICAgICgodGh1bWJYID49IHNpYmxpbmdYICYmIHRodW1iWCA8PSBzaWJsaW5nWCArIHNpYmxpbmdXaWR0aCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHRodW1iWCArIHRodW1iWFdpZHRoID49IHNpYmxpbmdYICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYlggKyB0aHVtYlhXaWR0aCA8PSBzaWJsaW5nWCArIHNpYmxpbmdXaWR0aCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvdmVybGFwcy5pbmNsdWRlcyhzaWJsaW5nSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBzLnB1c2godGh1bWJJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBzLnB1c2goc2libGluZ0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHMgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIG92ZXJsYXBzLCB0cnVlKSwgW3RodW1iSW5kZXgsIHNpYmxpbmdJbmRleF0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRPdmVybGFwcyhzaWJsaW5nSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBidWlsZE92ZXJsYXBzKGluZGV4KTtcbiAgICAvLyBTb3J0IGFuZCByZW1vdmUgZHVwbGljYXRlcyBmcm9tIHRoZSBidWlsdCBvdmVybGFwc1xuICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQob3ZlcmxhcHMuc29ydCgpKSk7XG59O1xuLyoqXG4gKiBBIGN1c3RvbSBSZWFjdCBIb29rIGZvciBjYWxjdWxhdGluZyB3aGV0aGVyIGEgdGh1bWIgb3ZlcmxhcHNcbiAqIGFub3RoZXIgYW5kIHdoZXRoZXIgbGFiZWxzIGNvdWxkL3Nob3VsZCBtZXJnZS5cbiAqIEBwYXJhbSByYW5nZVJlZiAtIFJlYWN0IHJlZiB2YWx1ZSBvZiBSYW5nZSBjb21wb25lbnRcbiAqIEBwYXJhbSB2YWx1ZXMgLSBjdXJyZW50IFJhbmdlIHZhbHVlcyBBcnJheVxuICogQHBhcmFtIGluZGV4IC0gdGh1bWIgaW5kZXhcbiAqIEBwYXJhbSBzdGVwIC0gc3RlcCB2YWx1ZSwgdXNlZCB0byBjYWxjdWxhdGUgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICogQHBhcmFtIHNlcGFyYXRvciAtIHN0cmluZyB0byBzZXBhcmF0ZSB0aHVtYiB2YWx1ZXNcbiAqIEByZXR1cm5zIGxhYmVsIHZhbHVlICsgc3R5bGluZyBmb3IgdGh1bWIgbGFiZWxcbiAqL1xudmFyIHVzZVRodW1iT3ZlcmxhcCA9IGZ1bmN0aW9uIChyYW5nZVJlZiwgdmFsdWVzLCBpbmRleCwgc3RlcCwgc2VwYXJhdG9yLCB2YWx1ZVRvTGFiZWwpIHtcbiAgICBpZiAoc3RlcCA9PT0gdm9pZCAwKSB7IHN0ZXAgPSAwLjE7IH1cbiAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDApIHsgc2VwYXJhdG9yID0gXCIgLSBcIjsgfVxuICAgIGlmICh2YWx1ZVRvTGFiZWwgPT09IHZvaWQgMCkgeyB2YWx1ZVRvTGFiZWwgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9OyB9XG4gICAgdmFyIGRlY2ltYWxQbGFjZXMgPSAoMCwgZXhwb3J0cy5nZXRTdGVwRGVjaW1hbHMpKHN0ZXApO1xuICAgIC8vIENyZWF0ZSBpbml0aWFsIGxhYmVsIHN0eWxlIGFuZCB2YWx1ZS4gTGFiZWwgdmFsdWUgZGVmYXVsdHMgdG8gdGh1bWIgdmFsdWVcbiAgICB2YXIgX2EgPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkoe30pLCBsYWJlbFN0eWxlID0gX2FbMF0sIHNldExhYmVsU3R5bGUgPSBfYVsxXTtcbiAgICB2YXIgX2IgPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkodmFsdWVUb0xhYmVsKHZhbHVlc1tpbmRleF0udG9GaXhlZChkZWNpbWFsUGxhY2VzKSkpLCBsYWJlbFZhbHVlID0gX2JbMF0sIHNldExhYmVsVmFsdWUgPSBfYlsxXTtcbiAgICAvLyBXaGVuIHRoZSByYW5nZVJlZiBvciB2YWx1ZXMgY2hhbmdlLCB1cGRhdGUgdGhlIFRodW1iIGxhYmVsIHZhbHVlcyBhbmQgc3R5bGluZ1xuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocmFuZ2VSZWYpIHtcbiAgICAgICAgICAgIHZhciB0aHVtYnMgPSByYW5nZVJlZi5nZXRUaHVtYnMoKTtcbiAgICAgICAgICAgIGlmICh0aHVtYnMubGVuZ3RoIDwgMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgbmV3U3R5bGUgPSB7fTtcbiAgICAgICAgICAgIHZhciBvZmZzZXRzXzEgPSByYW5nZVJlZi5nZXRPZmZzZXRzKCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBhbnkgb3ZlcmxhcHMgZm9yIHRoZSBnaXZlbiBUaHVtYiBpbmRleC4gVGhpcyBtdXN0IHJldHVybiBhbGwgbGlua2VkXG4gICAgICAgICAgICAgKiBUaHVtYnMuIFNvIGlmIHRoZXJlIGFyZSA0IFRodW1icyBhbmQgVGh1bWJzIDIsIDMgYW5kIDQgb3ZlcmxhcC4gSWYgd2UgYXJlXG4gICAgICAgICAgICAgKiBnZXR0aW5nIHRoZSBvdmVybGFwcyBmb3IgVGh1bWIgMSBhbmQgaXQgb3ZlcmxhcHMgb25seSBUaHVtYiAyLCB3ZSBtdXN0IGdldFxuICAgICAgICAgICAgICogMiwgMyBhbmQgNCBhbHNvLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgb3ZlcmxhcHMgPSBnZXRPdmVybGFwcyhpbmRleCwgb2Zmc2V0c18xLCB0aHVtYnMsIHZhbHVlcywgc2VwYXJhdG9yLCBkZWNpbWFsUGxhY2VzLCB2YWx1ZVRvTGFiZWwpO1xuICAgICAgICAgICAgLy8gU2V0IGEgZGVmYXVsdCBsYWJlbCB2YWx1ZSBvZiB0aGUgVGh1bWIgdmFsdWVcbiAgICAgICAgICAgIHZhciBsYWJlbFZhbHVlXzEgPSB2YWx1ZVRvTGFiZWwodmFsdWVzW2luZGV4XS50b0ZpeGVkKGRlY2ltYWxQbGFjZXMpKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhlcmUgYXJlIG92ZXJsYXBzIGZvciB0aGUgVGh1bWIsIHdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0XG4gICAgICAgICAgICAgKiBMYWJlbCB2YWx1ZSBhbG9uZyB3aXRoIHRoZSByZWxldmFudCBzdHlsaW5nLiBXZSBvbmx5IHdhbnQgdG8gc2hvdyBhIExhYmVsXG4gICAgICAgICAgICAgKiBmb3IgdGhlIGxlZnQgbW9zdCBUaHVtYiBpbiBhbiBvdmVybGFwcGluZyBzZXQuXG4gICAgICAgICAgICAgKiBBbGwgb3RoZXIgVGh1bWJzIHdpbGwgYmUgc2V0IHRvIGRpc3BsYXk6IG5vbmUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChvdmVybGFwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBHZXQgYW4gQXJyYXkgb2YgdGhlIG9mZnNldHMgZm9yIHRoZSBvdmVybGFwcGluZyBUaHVtYnNcbiAgICAgICAgICAgICAgICAgKiBUaGlzIGlzIHNvIHdlIGNhbiBkZXRlcm1pbmUgaWYgdGhlIFRodW1iIHdlIGFyZSBsb29raW5nIGF0XG4gICAgICAgICAgICAgICAgICogaXMgdGhlIGxlZnQgbW9zdCB0aHVtYiBpbiBhbiBvdmVybGFwcGluZyBzZXRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0c1ggPSBvdmVybGFwcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGMsIGksIHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoID8gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBhLCB0cnVlKSwgW29mZnNldHNfMVtzW2ldXS54XSwgZmFsc2UpIDogW29mZnNldHNfMVtzW2ldXS54XTtcbiAgICAgICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgb3VyIFRodW1iIGlzIHRoZSBsZWZ0IG1vc3QgVGh1bWIsIHdlIGNhbiBidWlsZCBhIExhYmVsIHZhbHVlXG4gICAgICAgICAgICAgICAgICogYW5kIHNldCB0aGUgc3R5bGUgZm9yIHRoYXQgTGFiZWxcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5taW4uYXBwbHkoTWF0aCwgb2Zmc2V0c1gpID09PSBvZmZzZXRzXzFbaW5kZXhdLngpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEZpcnN0IGNhbGN1bGF0ZSB0aGUgTGFiZWwgdmFsdWUuIFRvIGRvIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAqIGdyYWIgYWxsIHRoZSB2YWx1ZXMgZm9yIHRoZSBUaHVtYnMgaW4gb3VyIG92ZXJsYXBzLlxuICAgICAgICAgICAgICAgICAgICAgKiBUaGVuIGNvbnZlcnQgdGhhdCB0byBhIFNldCBhbmQgc29ydCBpdCB3aGlsc3QgcmVtb3ZpbmcgZHVwbGljYXRlcy5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbFZhbHVlc18xID0gW107XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBzLmZvckVhY2goZnVuY3Rpb24gKHRodW1iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbFZhbHVlc18xLnB1c2godmFsdWVzW3RodW1iXS50b0ZpeGVkKGRlY2ltYWxQbGFjZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiAgVXBkYXRlIHRoZSBsYWJlbFZhbHVlIHdpdGggdGhlIHJlc3VsdGluZyBBcnJheVxuICAgICAgICAgICAgICAgICAgICAgKiAgam9pbmVkIGJ5IG91ciBkZWZpbmVkIHNlcGFyYXRvclxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgbGFiZWxWYWx1ZV8xID0gQXJyYXkuZnJvbShuZXcgU2V0KGxhYmVsVmFsdWVzXzEuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gcGFyc2VGbG9hdChhKSAtIHBhcnNlRmxvYXQoYik7IH0pKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAodmFsdWVUb0xhYmVsKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIExhc3RseSwgYnVpbGQgdGhlIGxhYmVsIHN0eWxpbmcuIFRoZSBsYWJlbCBzdHlsaW5nIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICogcG9zaXRpb24gdGhlIGxhYmVsIGFuZCBhcHBseSBhIHRyYW5zZm9ybSBzbyB0aGF0IGl0J3MgY2VudGVyZWQuXG4gICAgICAgICAgICAgICAgICAgICAqIFdlIHdhbnQgdGhlIGNlbnRlciBwb2ludCBiZXR3ZWVuIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGxlZnQgbW9zdCBUaHVtYlxuICAgICAgICAgICAgICAgICAgICAgKiBhbmQgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIHJpZ2h0IG1vc3QgVGh1bWIuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBvZmZzZXRzWCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgb2Zmc2V0c1gpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdFdpZHRoID0gdGh1bWJzW292ZXJsYXBzW29mZnNldHNYLmluZGV4T2YobGFzdCldXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBuZXdTdHlsZS5sZWZ0ID0gXCJcIi5jb25jYXQoTWF0aC5hYnMoZmlyc3QgLSAobGFzdCArIGxhc3RXaWR0aCkpIC8gMiwgXCJweFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoLTUwJSwgMClcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBUaHVtYiBpc24ndCB0aGUgbGVmdCBtb3N0IFRodW1iLCBoaWRlIHRoZSBMYWJlbCFcbiAgICAgICAgICAgICAgICAgICAgbmV3U3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsYWJlbCB2YWx1ZSBhbmQgc3R5bGVcbiAgICAgICAgICAgIHNldExhYmVsVmFsdWUobGFiZWxWYWx1ZV8xKTtcbiAgICAgICAgICAgIHNldExhYmVsU3R5bGUobmV3U3R5bGUpO1xuICAgICAgICB9XG4gICAgfSwgW3JhbmdlUmVmLCB2YWx1ZXNdKTtcbiAgICByZXR1cm4gW2xhYmVsVmFsdWUsIGxhYmVsU3R5bGVdO1xufTtcbmV4cG9ydHMudXNlVGh1bWJPdmVybGFwID0gdXNlVGh1bWJPdmVybGFwO1xuLyoqXG4gKiBVdGlsIGZ1bmN0aW9uIGZvciBjYWxjdWxhdGluZyB0aGUgZGlzdGFuY2Ugb2YgdGhlIGNlbnRlciBvZiBhIHRodW1iXG4gKiBmb3JtIGEgZ2l2ZW4gbW91c2UvdG91Y2ggdGFyZ2V0J3MgcG9zaXRpb25cbiAqIEBwYXJhbSB0aHVtYkVsIC0gVGh1bWIgZWxlbWVudCB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGZyb21cbiAqIEBwYXJhbSBjbGllbnRYIC0gdGFyZ2V0IHggcG9zaXRpb24gKG1vdXNlL3RvdWNoKVxuICogQHBhcmFtIGNsaWVudFkgLSB0YXJnZXQgeSBwb3NpdGlvbiAobW91c2UvdG91Y2gpXG4gKiBAcGFyYW0gZGlyZWN0aW9uIC0gdGhlIGRpcmVjdGlvbiBvZiB0aGUgdHJhY2tcbiAqL1xuZnVuY3Rpb24gZ2V0VGh1bWJEaXN0YW5jZSh0aHVtYkVsLCBjbGllbnRYLCBjbGllbnRZLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgX2EgPSB0aHVtYkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBsZWZ0ID0gX2EubGVmdCwgdG9wID0gX2EudG9wLCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgcmV0dXJuIGlzVmVydGljYWwoZGlyZWN0aW9uKVxuICAgICAgICA/IE1hdGguYWJzKGNsaWVudFkgLSAodG9wICsgaGVpZ2h0IC8gMikpXG4gICAgICAgIDogTWF0aC5hYnMoY2xpZW50WCAtIChsZWZ0ICsgd2lkdGggLyAyKSk7XG59XG52YXIgaXNJT1MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB2YXIgcGxhdGZvcm0gPSAoKF9hID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wbGF0Zm9ybSkgfHwgbmF2aWdhdG9yLnBsYXRmb3JtO1xuICAgIHJldHVybiAoW1xuICAgICAgICBcImlQYWQgU2ltdWxhdG9yXCIsXG4gICAgICAgIFwiaVBob25lIFNpbXVsYXRvclwiLFxuICAgICAgICBcImlQb2QgU2ltdWxhdG9yXCIsXG4gICAgICAgIFwiaVBhZFwiLFxuICAgICAgICBcImlQaG9uZVwiLFxuICAgICAgICBcImlQb2RcIixcbiAgICBdLmluY2x1ZGVzKHBsYXRmb3JtKSB8fFxuICAgICAgICAvLyBpUGFkIG9uIGlPUyAxMyBkZXRlY3Rpb25cbiAgICAgICAgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJNYWNcIikgJiYgXCJvbnRvdWNoZW5kXCIgaW4gZG9jdW1lbnQpKTtcbn07XG5leHBvcnRzLmlzSU9TID0gaXNJT1M7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-range/lib/utils.js\n");

/***/ })

};
;